"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/glob";
exports.ids = ["vendor-chunks/glob"];
exports.modules = {

/***/ "(rsc)/./node_modules/glob/dist/esm/glob.js":
/*!********************************************!*\
  !*** ./node_modules/glob/dist/esm/glob.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Glob: () => (/* binding */ Glob)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var path_scurry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-scurry */ \"(rsc)/./node_modules/path-scurry/dist/esm/index.js\");\n/* harmony import */ var _pattern_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/esm/pattern.js\");\n/* harmony import */ var _walker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./walker.js */ \"(rsc)/./node_modules/glob/dist/esm/walker.js\");\n\n\n\n\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * An object that can perform glob pattern traversals.\n */\nclass Glob {\n    absolute;\n    cwd;\n    root;\n    dot;\n    dotRelative;\n    follow;\n    ignore;\n    magicalBraces;\n    mark;\n    matchBase;\n    maxDepth;\n    nobrace;\n    nocase;\n    nodir;\n    noext;\n    noglobstar;\n    pattern;\n    platform;\n    realpath;\n    scurry;\n    stat;\n    signal;\n    windowsPathsNoEscape;\n    withFileTypes;\n    includeChildMatches;\n    /**\n     * The options provided to the constructor.\n     */\n    opts;\n    /**\n     * An array of parsed immutable {@link Pattern} objects.\n     */\n    patterns;\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */\n    constructor(pattern, opts) {\n        /* c8 ignore start */\n        if (!opts)\n            throw new TypeError('glob options required');\n        /* c8 ignore stop */\n        this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = '';\n        }\n        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n            opts.cwd = (0,node_url__WEBPACK_IMPORTED_MODULE_1__.fileURLToPath)(opts.cwd);\n        }\n        this.cwd = opts.cwd || '';\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth =\n            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error('cannot set absolute and withFileTypes:true');\n        }\n        if (typeof pattern === 'string') {\n            pattern = [pattern];\n        }\n        this.windowsPathsNoEscape =\n            !!opts.windowsPathsNoEscape ||\n                opts.allowWindowsEscape ===\n                    false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map(p => p.replace(/\\\\/g, '/'));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError('base matching requires globstar');\n            }\n            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = { ...opts, platform: this.platform };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined &&\n                opts.nocase !== opts.scurry.nocase) {\n                throw new Error('nocase option contradicts provided scurry option');\n            }\n        }\n        else {\n            const Scurry = opts.platform === 'win32' ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryWin32\n                : opts.platform === 'darwin' ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryDarwin\n                    : opts.platform ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryPosix\n                        : path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs,\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug,\n        };\n        const mms = this.pattern.map(p => new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m) => {\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [[], []]);\n        this.patterns = matchSet.map((set, i) => {\n            const g = globParts[i];\n            /* c8 ignore start */\n            if (!g)\n                throw new Error('invalid pattern object');\n            /* c8 ignore stop */\n            return new _pattern_js__WEBPACK_IMPORTED_MODULE_3__.Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...(await new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walk()),\n        ];\n    }\n    walkSync() {\n        return [\n            ...new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walkSync(),\n        ];\n    }\n    stream() {\n        return new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).stream();\n    }\n    streamSync() {\n        return new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */\n    iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */\n    iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9nbG9iLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzQztBQUNHO0FBQ3FEO0FBQ3ZEO0FBQ2M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdEQUFlO0FBQ3RFLCtDQUErQyx5REFBZ0I7QUFDL0Qsc0NBQXNDLHdEQUFlO0FBQ3JELDBCQUEwQixtREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnREFBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU87QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWtlcGluMnIvRG9jdW1lbnRzL3Byb2plY3RzL21ha2VwaW4yci5naXRodWIuaW8vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vZ2xvYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNaW5pbWF0Y2ggfSBmcm9tICdtaW5pbWF0Y2gnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IFBhdGhTY3VycnksIFBhdGhTY3VycnlEYXJ3aW4sIFBhdGhTY3VycnlQb3NpeCwgUGF0aFNjdXJyeVdpbjMyLCB9IGZyb20gJ3BhdGgtc2N1cnJ5JztcbmltcG9ydCB7IFBhdHRlcm4gfSBmcm9tICcuL3BhdHRlcm4uanMnO1xuaW1wb3J0IHsgR2xvYlN0cmVhbSwgR2xvYldhbGtlciB9IGZyb20gJy4vd2Fsa2VyLmpzJztcbi8vIGlmIG5vIHByb2Nlc3MgZ2xvYmFsLCBqdXN0IGNhbGwgaXQgbGludXguXG4vLyBzbyB3ZSBkZWZhdWx0IHRvIGNhc2Utc2Vuc2l0aXZlLCAvIHNlcGFyYXRvcnNcbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucGxhdGZvcm0gPT09ICdzdHJpbmcnKSA/XG4gICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ2xpbnV4Jztcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHBlcmZvcm0gZ2xvYiBwYXR0ZXJuIHRyYXZlcnNhbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBHbG9iIHtcbiAgICBhYnNvbHV0ZTtcbiAgICBjd2Q7XG4gICAgcm9vdDtcbiAgICBkb3Q7XG4gICAgZG90UmVsYXRpdmU7XG4gICAgZm9sbG93O1xuICAgIGlnbm9yZTtcbiAgICBtYWdpY2FsQnJhY2VzO1xuICAgIG1hcms7XG4gICAgbWF0Y2hCYXNlO1xuICAgIG1heERlcHRoO1xuICAgIG5vYnJhY2U7XG4gICAgbm9jYXNlO1xuICAgIG5vZGlyO1xuICAgIG5vZXh0O1xuICAgIG5vZ2xvYnN0YXI7XG4gICAgcGF0dGVybjtcbiAgICBwbGF0Zm9ybTtcbiAgICByZWFscGF0aDtcbiAgICBzY3Vycnk7XG4gICAgc3RhdDtcbiAgICBzaWduYWw7XG4gICAgd2luZG93c1BhdGhzTm9Fc2NhcGU7XG4gICAgd2l0aEZpbGVUeXBlcztcbiAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBvcHRzO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHBhcnNlZCBpbW11dGFibGUge0BsaW5rIFBhdHRlcm59IG9iamVjdHMuXG4gICAgICovXG4gICAgcGF0dGVybnM7XG4gICAgLyoqXG4gICAgICogQWxsIG9wdGlvbnMgYXJlIHN0b3JlZCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBgR2xvYmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBHbG9iT3B0aW9uc30gZm9yIGZ1bGwgb3B0aW9ucyBkZXNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYSBwcmV2aW91cyBgR2xvYmAgb2JqZWN0IGNhbiBiZSBwYXNzZWQgYXMgdGhlXG4gICAgICogYEdsb2JPcHRpb25zYCB0byBhbm90aGVyIGBHbG9iYCBpbnN0YW50aWF0aW9uIHRvIHJlLXVzZSBzZXR0aW5nc1xuICAgICAqIGFuZCBjYWNoZXMgd2l0aCBhIG5ldyBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogVHJhdmVyc2FsIGZ1bmN0aW9ucyBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJ1biB0aGUgd2Fsa1xuICAgICAqIGFnYWluLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdHMpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2Igb3B0aW9ucyByZXF1aXJlZCcpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLndpdGhGaWxlVHlwZXMgPSAhIW9wdHMud2l0aEZpbGVUeXBlcztcbiAgICAgICAgdGhpcy5zaWduYWwgPSBvcHRzLnNpZ25hbDtcbiAgICAgICAgdGhpcy5mb2xsb3cgPSAhIW9wdHMuZm9sbG93O1xuICAgICAgICB0aGlzLmRvdCA9ICEhb3B0cy5kb3Q7XG4gICAgICAgIHRoaXMuZG90UmVsYXRpdmUgPSAhIW9wdHMuZG90UmVsYXRpdmU7XG4gICAgICAgIHRoaXMubm9kaXIgPSAhIW9wdHMubm9kaXI7XG4gICAgICAgIHRoaXMubWFyayA9ICEhb3B0cy5tYXJrO1xuICAgICAgICBpZiAoIW9wdHMuY3dkKSB7XG4gICAgICAgICAgICB0aGlzLmN3ZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuY3dkIGluc3RhbmNlb2YgVVJMIHx8IG9wdHMuY3dkLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xuICAgICAgICAgICAgb3B0cy5jd2QgPSBmaWxlVVJMVG9QYXRoKG9wdHMuY3dkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN3ZCA9IG9wdHMuY3dkIHx8ICcnO1xuICAgICAgICB0aGlzLnJvb3QgPSBvcHRzLnJvb3Q7XG4gICAgICAgIHRoaXMubWFnaWNhbEJyYWNlcyA9ICEhb3B0cy5tYWdpY2FsQnJhY2VzO1xuICAgICAgICB0aGlzLm5vYnJhY2UgPSAhIW9wdHMubm9icmFjZTtcbiAgICAgICAgdGhpcy5ub2V4dCA9ICEhb3B0cy5ub2V4dDtcbiAgICAgICAgdGhpcy5yZWFscGF0aCA9ICEhb3B0cy5yZWFscGF0aDtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZSA9IG9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyA9IG9wdHMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9nbG9ic3RhciA9ICEhb3B0cy5ub2dsb2JzdGFyO1xuICAgICAgICB0aGlzLm1hdGNoQmFzZSA9ICEhb3B0cy5tYXRjaEJhc2U7XG4gICAgICAgIHRoaXMubWF4RGVwdGggPVxuICAgICAgICAgICAgdHlwZW9mIG9wdHMubWF4RGVwdGggPT09ICdudW1iZXInID8gb3B0cy5tYXhEZXB0aCA6IEluZmluaXR5O1xuICAgICAgICB0aGlzLnN0YXQgPSAhIW9wdHMuc3RhdDtcbiAgICAgICAgdGhpcy5pZ25vcmUgPSBvcHRzLmlnbm9yZTtcbiAgICAgICAgaWYgKHRoaXMud2l0aEZpbGVUeXBlcyAmJiB0aGlzLmFic29sdXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBhYnNvbHV0ZSBhbmQgd2l0aEZpbGVUeXBlczp0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybiA9IFtwYXR0ZXJuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlID1cbiAgICAgICAgICAgICEhb3B0cy53aW5kb3dzUGF0aHNOb0VzY2FwZSB8fFxuICAgICAgICAgICAgICAgIG9wdHMuYWxsb3dXaW5kb3dzRXNjYXBlID09PVxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLm1hcChwID0+IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXRjaEJhc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXNlIG1hdGNoaW5nIHJlcXVpcmVzIGdsb2JzdGFyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5tYXAocCA9PiAocC5pbmNsdWRlcygnLycpID8gcCA6IGAuLyoqLyR7cH1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdHMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtIH07XG4gICAgICAgIGlmIChvcHRzLnNjdXJyeSkge1xuICAgICAgICAgICAgdGhpcy5zY3VycnkgPSBvcHRzLnNjdXJyeTtcbiAgICAgICAgICAgIGlmIChvcHRzLm5vY2FzZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb3B0cy5ub2Nhc2UgIT09IG9wdHMuc2N1cnJ5Lm5vY2FzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9jYXNlIG9wdGlvbiBjb250cmFkaWN0cyBwcm92aWRlZCBzY3Vycnkgb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBTY3VycnkgPSBvcHRzLnBsYXRmb3JtID09PSAnd2luMzInID8gUGF0aFNjdXJyeVdpbjMyXG4gICAgICAgICAgICAgICAgOiBvcHRzLnBsYXRmb3JtID09PSAnZGFyd2luJyA/IFBhdGhTY3VycnlEYXJ3aW5cbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLnBsYXRmb3JtID8gUGF0aFNjdXJyeVBvc2l4XG4gICAgICAgICAgICAgICAgICAgICAgICA6IFBhdGhTY3Vycnk7XG4gICAgICAgICAgICB0aGlzLnNjdXJyeSA9IG5ldyBTY3VycnkodGhpcy5jd2QsIHtcbiAgICAgICAgICAgICAgICBub2Nhc2U6IG9wdHMubm9jYXNlLFxuICAgICAgICAgICAgICAgIGZzOiBvcHRzLmZzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2Nhc2UgPSB0aGlzLnNjdXJyeS5ub2Nhc2U7XG4gICAgICAgIC8vIElmIHlvdSBkbyBub2Nhc2U6dHJ1ZSBvbiBhIGNhc2Utc2Vuc2l0aXZlIGZpbGUgc3lzdGVtLCB0aGVuXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHJlZ2V4cHMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvciBub24tbWFnaWNcbiAgICAgICAgLy8gcGF0aCBwb3J0aW9ucywgYmVjYXVzZSBzdGF0dGluZyBgYUJjYCB3b24ndCByZXR1cm4gcmVzdWx0c1xuICAgICAgICAvLyBmb3IgdGhlIGZpbGUgYEFiQ2AgZm9yIGV4YW1wbGUuXG4gICAgICAgIGNvbnN0IG5vY2FzZU1hZ2ljT25seSA9IHRoaXMucGxhdGZvcm0gPT09ICdkYXJ3aW4nIHx8IHRoaXMucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIGNvbnN0IG1tbyA9IHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgbm9jYXNlIGJhc2VkIG9uIHBsYXRmb3JtXG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgZG90OiB0aGlzLmRvdCxcbiAgICAgICAgICAgIG1hdGNoQmFzZTogdGhpcy5tYXRjaEJhc2UsXG4gICAgICAgICAgICBub2JyYWNlOiB0aGlzLm5vYnJhY2UsXG4gICAgICAgICAgICBub2Nhc2U6IHRoaXMubm9jYXNlLFxuICAgICAgICAgICAgbm9jYXNlTWFnaWNPbmx5LFxuICAgICAgICAgICAgbm9jb21tZW50OiB0cnVlLFxuICAgICAgICAgICAgbm9leHQ6IHRoaXMubm9leHQsXG4gICAgICAgICAgICBub25lZ2F0ZTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGltaXphdGlvbkxldmVsOiAyLFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTogdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSxcbiAgICAgICAgICAgIGRlYnVnOiAhIXRoaXMub3B0cy5kZWJ1ZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW1zID0gdGhpcy5wYXR0ZXJuLm1hcChwID0+IG5ldyBNaW5pbWF0Y2gocCwgbW1vKSk7XG4gICAgICAgIGNvbnN0IFttYXRjaFNldCwgZ2xvYlBhcnRzXSA9IG1tcy5yZWR1Y2UoKHNldCwgbSkgPT4ge1xuICAgICAgICAgICAgc2V0WzBdLnB1c2goLi4ubS5zZXQpO1xuICAgICAgICAgICAgc2V0WzFdLnB1c2goLi4ubS5nbG9iUGFydHMpO1xuICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgfSwgW1tdLCBbXV0pO1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gbWF0Y2hTZXQubWFwKChzZXQsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBnbG9iUGFydHNbaV07XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICghZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGF0dGVybiBvYmplY3QnKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdHRlcm4oc2V0LCBnLCAwLCB0aGlzLnBsYXRmb3JtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHdhbGsoKSB7XG4gICAgICAgIC8vIFdhbGtlcnMgYWx3YXlzIHJldHVybiBhcnJheSBvZiBQYXRoIG9iamVjdHMsIHNvIHdlIGp1c3QgaGF2ZSB0b1xuICAgICAgICAvLyBjb2VyY2UgdGhlbSBpbnRvIHRoZSByaWdodCBzaGFwZS4gIEl0IHdpbGwgaGF2ZSBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAvLyByZWFscGF0aCgpIGlmIHRoZSBvcHRpb24gd2FzIHNldCB0byBkbyBzbywgc28gd2Uga25vdyB0aGF0J3MgY2FjaGVkLlxuICAgICAgICAvLyBzdGFydCBvdXQga25vd2luZyB0aGUgY3dkLCBhdCBsZWFzdFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uKGF3YWl0IG5ldyBHbG9iV2Fsa2VyKHRoaXMucGF0dGVybnMsIHRoaXMuc2N1cnJ5LmN3ZCwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heERlcHRoICsgdGhpcy5zY3VycnkuY3dkLmRlcHRoKClcbiAgICAgICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICBub2Nhc2U6IHRoaXMubm9jYXNlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgICAgIH0pLndhbGsoKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHdhbGtTeW5jKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4ubmV3IEdsb2JXYWxrZXIodGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICAgICAgfSkud2Fsa1N5bmMoKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgc3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdsb2JTdHJlYW0odGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgIH0pLnN0cmVhbSgpO1xuICAgIH1cbiAgICBzdHJlYW1TeW5jKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdsb2JTdHJlYW0odGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgP1xuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgIH0pLnN0cmVhbVN5bmMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzeW5jIGl0ZXJhdGlvbiBmdW5jdGlvbi4gUmV0dXJucyBhIEdlbmVyYXRvciB0aGF0XG4gICAgICogaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBpdGVyYXRlU3luYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtU3luYygpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVTeW5jKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYXN5bmMgaXRlcmF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGFuIEFzeW5jR2VuZXJhdG9yIHRoYXRcbiAgICAgKiBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGl0ZXJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbSgpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/glob.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/has-magic.js":
/*!*************************************************!*\
  !*** ./node_modules/glob/dist/esm/has-magic.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasMagic: () => (/* binding */ hasMagic)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\");\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nconst hasMagic = (pattern, options = {}) => {\n    if (!Array.isArray(pattern)) {\n        pattern = [pattern];\n    }\n    for (const p of pattern) {\n        if (new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p, options).hasMagic())\n            return true;\n    }\n    return false;\n};\n//# sourceMappingURL=has-magic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9oYXMtbWFnaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21ha2VwaW4yci9Eb2N1bWVudHMvcHJvamVjdHMvbWFrZXBpbjJyLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9oYXMtbWFnaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWluaW1hdGNoIH0gZnJvbSAnbWluaW1hdGNoJztcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBhdHRlcm5zIHByb3ZpZGVkIGNvbnRhaW4gYW55IG1hZ2ljIGdsb2IgY2hhcmFjdGVycyxcbiAqIGdpdmVuIHRoZSBvcHRpb25zIHByb3ZpZGVkLlxuICpcbiAqIEJyYWNlIGV4cGFuc2lvbiBpcyBub3QgY29uc2lkZXJlZCBcIm1hZ2ljXCIgdW5sZXNzIHRoZSBgbWFnaWNhbEJyYWNlc2Agb3B0aW9uXG4gKiBpcyBzZXQsIGFzIGJyYWNlIGV4cGFuc2lvbiBqdXN0IHR1cm5zIG9uZSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogU28gYSBwYXR0ZXJuIGxpa2UgYCd4e2EsYn15J2Agd291bGQgcmV0dXJuIGBmYWxzZWAsIGJlY2F1c2UgYCd4YXknYCBhbmRcbiAqIGAneGJ5J2AgYm90aCBkbyBub3QgY29udGFpbiBhbnkgbWFnaWMgZ2xvYiBjaGFyYWN0ZXJzLCBhbmQgaXQncyB0cmVhdGVkIHRoZVxuICogc2FtZSBhcyBpZiB5b3UgaGFkIGNhbGxlZCBpdCBvbiBgWyd4YXknLCAneGJ5J11gLiBXaGVuIGBtYWdpY2FsQnJhY2VzOnRydWVgXG4gKiBpcyBpbiB0aGUgb3B0aW9ucywgYnJhY2UgZXhwYW5zaW9uIF9pc18gdHJlYXRlZCBhcyBhIHBhdHRlcm4gaGF2aW5nIG1hZ2ljLlxuICovXG5leHBvcnQgY29uc3QgaGFzTWFnaWMgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICAgIHBhdHRlcm4gPSBbcGF0dGVybl07XG4gICAgfVxuICAgIGZvciAoY29uc3QgcCBvZiBwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChuZXcgTWluaW1hdGNoKHAsIG9wdGlvbnMpLmhhc01hZ2ljKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1tYWdpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/has-magic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/ignore.js":
/*!**********************************************!*\
  !*** ./node_modules/glob/dist/esm/ignore.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ignore: () => (/* binding */ Ignore)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var _pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/esm/pattern.js\");\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\n\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    platform;\n    mmopts;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        for (const ign of ignored)\n            this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(ign, this.mmopts);\n        for (let i = 0; i < mm.set.length; i++) {\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */\n            if (!parsed || !globParts) {\n                throw new Error('invalid pattern object');\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while (parsed[0] === '.' && globParts[0] === '.') {\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */\n            const p = new _pattern_js__WEBPACK_IMPORTED_MODULE_1__.Pattern(parsed, globParts, 0, this.platform);\n            const m = new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === '**';\n            const absolute = p.isAbsolute();\n            if (absolute)\n                this.absolute.push(m);\n            else\n                this.relative.push(m);\n            if (children) {\n                if (absolute)\n                    this.absoluteChildren.push(m);\n                else\n                    this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=ignore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9pZ25vcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWlFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQVM7QUFDaEMsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBTztBQUNqQywwQkFBMEIsZ0RBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWFrZXBpbjJyL0RvY3VtZW50cy9wcm9qZWN0cy9tYWtlcGluMnIuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2lnbm9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnaXZlIGl0IGEgcGF0dGVybiwgYW5kIGl0J2xsIGJlIGFibGUgdG8gdGVsbCB5b3UgaWZcbi8vIGEgZ2l2ZW4gcGF0aCBzaG91bGQgYmUgaWdub3JlZC5cbi8vIElnbm9yaW5nIGEgcGF0aCBpZ25vcmVzIGl0cyBjaGlsZHJlbiBpZiB0aGUgcGF0dGVybiBlbmRzIGluIC8qKlxuLy8gSWdub3JlcyBhcmUgYWx3YXlzIHBhcnNlZCBpbiBkb3Q6dHJ1ZSBtb2RlXG5pbXBvcnQgeyBNaW5pbWF0Y2ggfSBmcm9tICdtaW5pbWF0Y2gnO1xuaW1wb3J0IHsgUGF0dGVybiB9IGZyb20gJy4vcGF0dGVybi5qcyc7XG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgcHJvY2VzcyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnBsYXRmb3JtID09PSAnc3RyaW5nJykgP1xuICAgIHByb2Nlc3MucGxhdGZvcm1cbiAgICA6ICdsaW51eCc7XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gcHJvY2VzcyBpZ25vcmVkIHBhdHRlcm5zXG4gKi9cbmV4cG9ydCBjbGFzcyBJZ25vcmUge1xuICAgIHJlbGF0aXZlO1xuICAgIHJlbGF0aXZlQ2hpbGRyZW47XG4gICAgYWJzb2x1dGU7XG4gICAgYWJzb2x1dGVDaGlsZHJlbjtcbiAgICBwbGF0Zm9ybTtcbiAgICBtbW9wdHM7XG4gICAgY29uc3RydWN0b3IoaWdub3JlZCwgeyBub2JyYWNlLCBub2Nhc2UsIG5vZXh0LCBub2dsb2JzdGFyLCBwbGF0Zm9ybSA9IGRlZmF1bHRQbGF0Zm9ybSwgfSkge1xuICAgICAgICB0aGlzLnJlbGF0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWJzb2x1dGUgPSBbXTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZUNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuYWJzb2x1dGVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMubW1vcHRzID0ge1xuICAgICAgICAgICAgZG90OiB0cnVlLFxuICAgICAgICAgICAgbm9icmFjZSxcbiAgICAgICAgICAgIG5vY2FzZSxcbiAgICAgICAgICAgIG5vZXh0LFxuICAgICAgICAgICAgbm9nbG9ic3RhcixcbiAgICAgICAgICAgIG9wdGltaXphdGlvbkxldmVsOiAyLFxuICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICBub2NvbW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBub25lZ2F0ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBpZ24gb2YgaWdub3JlZClcbiAgICAgICAgICAgIHRoaXMuYWRkKGlnbik7XG4gICAgfVxuICAgIGFkZChpZ24pIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGxpdHRsZSB3ZWlyZCwgYnV0IGl0IGdpdmVzIHVzIGEgY2xlYW4gc2V0IG9mIG9wdGltaXplZFxuICAgICAgICAvLyBtaW5pbWF0Y2ggbWF0Y2hlcnMsIHdpdGhvdXQgZ2V0dGluZyB0cmlwcGVkIHVwIGlmIG9uZSBvZiB0aGVtXG4gICAgICAgIC8vIGVuZHMgaW4gLyoqIGluc2lkZSBhIGJyYWNlIHNlY3Rpb24sIGFuZCBpdCdzIG9ubHkgaW5lZmZpY2llbnQgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0IG9mIHRoZSB3YWxrLCBub3QgYWxvbmcgaXQuXG4gICAgICAgIC8vIEl0J2QgYmUgbmljZSBpZiB0aGUgUGF0dGVybiBjbGFzcyBqdXN0IGhhZCBhIC50ZXN0KCkgbWV0aG9kLCBidXRcbiAgICAgICAgLy8gaGFuZGxpbmcgZ2xvYnN0YXJzIGlzIGEgYml0IG9mIGEgcGl0YSwgYW5kIHRoYXQgY29kZSBhbHJlYWR5IGxpdmVzXG4gICAgICAgIC8vIGluIG1pbmltYXRjaCBhbnl3YXkuXG4gICAgICAgIC8vIEFub3RoZXIgd2F5IHdvdWxkIGJlIGlmIG1heWJlIE1pbmltYXRjaCBjb3VsZCB0YWtlIGl0cyBzZXQvZ2xvYlBhcnRzXG4gICAgICAgIC8vIGFzIGFuIG9wdGlvbiwgYW5kIHRoZW4gd2UgY291bGQgYXQgbGVhc3QganVzdCB1c2UgUGF0dGVybiB0byB0ZXN0XG4gICAgICAgIC8vIGZvciBhYnNvbHV0ZS1uZXNzLlxuICAgICAgICAvLyBZZXQgYW5vdGhlciB3YXksIE1pbmltYXRjaCBjb3VsZCB0YWtlIGFuIGFycmF5IG9mIGdsb2Igc3RyaW5ncywgYW5kXG4gICAgICAgIC8vIGEgY3dkIG9wdGlvbiwgYW5kIGRvIHRoZSByaWdodCB0aGluZy5cbiAgICAgICAgY29uc3QgbW0gPSBuZXcgTWluaW1hdGNoKGlnbiwgdGhpcy5tbW9wdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1tLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbW0uc2V0W2ldO1xuICAgICAgICAgICAgY29uc3QgZ2xvYlBhcnRzID0gbW0uZ2xvYlBhcnRzW2ldO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoIXBhcnNlZCB8fCAhZ2xvYlBhcnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhdHRlcm4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHJpcCBvZmYgbGVhZGluZyAuLyBwb3J0aW9uc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzU3MFxuICAgICAgICAgICAgd2hpbGUgKHBhcnNlZFswXSA9PT0gJy4nICYmIGdsb2JQYXJ0c1swXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZ2xvYlBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQYXR0ZXJuKHBhcnNlZCwgZ2xvYlBhcnRzLCAwLCB0aGlzLnBsYXRmb3JtKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWluaW1hdGNoKHAuZ2xvYlN0cmluZygpLCB0aGlzLm1tb3B0cyk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdsb2JQYXJ0c1tnbG9iUGFydHMubGVuZ3RoIC0gMV0gPT09ICcqKic7XG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZSA9IHAuaXNBYnNvbHV0ZSgpO1xuICAgICAgICAgICAgaWYgKGFic29sdXRlKVxuICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGUucHVzaChtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlLnB1c2gobSk7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVDaGlsZHJlbi5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZUNoaWxkcmVuLnB1c2gobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlZChwKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gcC5mdWxscGF0aCgpO1xuICAgICAgICBjb25zdCBmdWxscGF0aHMgPSBgJHtmdWxscGF0aH0vYDtcbiAgICAgICAgY29uc3QgcmVsYXRpdmUgPSBwLnJlbGF0aXZlKCkgfHwgJy4nO1xuICAgICAgICBjb25zdCByZWxhdGl2ZXMgPSBgJHtyZWxhdGl2ZX0vYDtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMucmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKHJlbGF0aXZlKSB8fCBtLm1hdGNoKHJlbGF0aXZlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMuYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKGZ1bGxwYXRoKSB8fCBtLm1hdGNoKGZ1bGxwYXRocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGlsZHJlbklnbm9yZWQocCkge1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHAuZnVsbHBhdGgoKSArICcvJztcbiAgICAgICAgY29uc3QgcmVsYXRpdmUgPSAocC5yZWxhdGl2ZSgpIHx8ICcuJykgKyAnLyc7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLnJlbGF0aXZlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKHJlbGF0aXZlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5hYnNvbHV0ZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChmdWxscGF0aCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/ignore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/glob/dist/esm/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Glob: () => (/* reexport safe */ _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob),\n/* harmony export */   Ignore: () => (/* reexport safe */ _ignore_js__WEBPACK_IMPORTED_MODULE_3__.Ignore),\n/* harmony export */   escape: () => (/* reexport safe */ minimatch__WEBPACK_IMPORTED_MODULE_0__.escape),\n/* harmony export */   glob: () => (/* binding */ glob),\n/* harmony export */   globIterate: () => (/* binding */ globIterate),\n/* harmony export */   globIterateSync: () => (/* binding */ globIterateSync),\n/* harmony export */   globStream: () => (/* binding */ globStream),\n/* harmony export */   globStreamSync: () => (/* binding */ globStreamSync),\n/* harmony export */   globSync: () => (/* binding */ globSync),\n/* harmony export */   hasMagic: () => (/* reexport safe */ _has_magic_js__WEBPACK_IMPORTED_MODULE_2__.hasMagic),\n/* harmony export */   iterate: () => (/* binding */ iterate),\n/* harmony export */   iterateSync: () => (/* binding */ iterateSync),\n/* harmony export */   stream: () => (/* binding */ stream),\n/* harmony export */   streamSync: () => (/* binding */ streamSync),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   unescape: () => (/* reexport safe */ minimatch__WEBPACK_IMPORTED_MODULE_0__.unescape)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var _glob_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/dist/esm/glob.js\");\n/* harmony import */ var _has_magic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/glob/dist/esm/has-magic.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/esm/ignore.js\");\n\n\n\n\n\n\n\nfunction globStreamSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).streamSync();\n}\nfunction globStream(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).stream();\n}\nfunction globSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).walk();\n}\nfunction globIterateSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).iterateSync();\n}\nfunction globIterate(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nconst streamSync = globStreamSync;\nconst stream = Object.assign(globStream, { sync: globStreamSync });\nconst iterateSync = globIterateSync;\nconst iterate = Object.assign(globIterate, {\n    sync: globIterateSync,\n});\nconst sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync,\n});\nconst glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync,\n    globStream,\n    stream,\n    globStreamSync,\n    streamSync,\n    globIterate,\n    iterate,\n    globIterateSync,\n    iterateSync,\n    Glob: _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob,\n    hasMagic: _has_magic_js__WEBPACK_IMPORTED_MODULE_2__.hasMagic,\n    escape: minimatch__WEBPACK_IMPORTED_MODULE_0__.escape,\n    unescape: minimatch__WEBPACK_IMPORTED_MODULE_0__.unescape,\n});\nglob.glob = glob;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUNaO0FBQ1M7QUFDRztBQUNaO0FBQ1M7QUFDTDtBQUM5Qiw2Q0FBNkM7QUFDcEQsZUFBZSwwQ0FBSTtBQUNuQjtBQUNPLHlDQUF5QztBQUNoRCxlQUFlLDBDQUFJO0FBQ25CO0FBQ08sdUNBQXVDO0FBQzlDLGVBQWUsMENBQUk7QUFDbkI7QUFDQSwwQ0FBMEM7QUFDMUMsZUFBZSwwQ0FBSTtBQUNuQjtBQUNPLDhDQUE4QztBQUNyRCxlQUFlLDBDQUFJO0FBQ25CO0FBQ08sMENBQTBDO0FBQ2pELGVBQWUsMENBQUk7QUFDbkI7QUFDQTtBQUNPO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ1A7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZO0FBQ1osVUFBVTtBQUNWLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21ha2VwaW4yci9Eb2N1bWVudHMvcHJvamVjdHMvbWFrZXBpbjJyLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlc2NhcGUsIHVuZXNjYXBlIH0gZnJvbSAnbWluaW1hdGNoJztcbmltcG9ydCB7IEdsb2IgfSBmcm9tICcuL2dsb2IuanMnO1xuaW1wb3J0IHsgaGFzTWFnaWMgfSBmcm9tICcuL2hhcy1tYWdpYy5qcyc7XG5leHBvcnQgeyBlc2NhcGUsIHVuZXNjYXBlIH0gZnJvbSAnbWluaW1hdGNoJztcbmV4cG9ydCB7IEdsb2IgfSBmcm9tICcuL2dsb2IuanMnO1xuZXhwb3J0IHsgaGFzTWFnaWMgfSBmcm9tICcuL2hhcy1tYWdpYy5qcyc7XG5leHBvcnQgeyBJZ25vcmUgfSBmcm9tICcuL2lnbm9yZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2xvYlN0cmVhbVN5bmMocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpLnN0cmVhbVN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbG9iU3RyZWFtKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5zdHJlYW0oKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucykud2Fsa1N5bmMoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdsb2JfKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKS53YWxrKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xvYkl0ZXJhdGVTeW5jKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5pdGVyYXRlU3luYygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JJdGVyYXRlKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5pdGVyYXRlKCk7XG59XG4vLyBhbGlhc2VzOiBnbG9iLnN5bmMuc3RyZWFtKCkgZ2xvYi5zdHJlYW0uc3luYygpIGdsb2Iuc3luYygpIGV0Y1xuZXhwb3J0IGNvbnN0IHN0cmVhbVN5bmMgPSBnbG9iU3RyZWFtU3luYztcbmV4cG9ydCBjb25zdCBzdHJlYW0gPSBPYmplY3QuYXNzaWduKGdsb2JTdHJlYW0sIHsgc3luYzogZ2xvYlN0cmVhbVN5bmMgfSk7XG5leHBvcnQgY29uc3QgaXRlcmF0ZVN5bmMgPSBnbG9iSXRlcmF0ZVN5bmM7XG5leHBvcnQgY29uc3QgaXRlcmF0ZSA9IE9iamVjdC5hc3NpZ24oZ2xvYkl0ZXJhdGUsIHtcbiAgICBzeW5jOiBnbG9iSXRlcmF0ZVN5bmMsXG59KTtcbmV4cG9ydCBjb25zdCBzeW5jID0gT2JqZWN0LmFzc2lnbihnbG9iU3luYywge1xuICAgIHN0cmVhbTogZ2xvYlN0cmVhbVN5bmMsXG4gICAgaXRlcmF0ZTogZ2xvYkl0ZXJhdGVTeW5jLFxufSk7XG5leHBvcnQgY29uc3QgZ2xvYiA9IE9iamVjdC5hc3NpZ24oZ2xvYl8sIHtcbiAgICBnbG9iOiBnbG9iXyxcbiAgICBnbG9iU3luYyxcbiAgICBzeW5jLFxuICAgIGdsb2JTdHJlYW0sXG4gICAgc3RyZWFtLFxuICAgIGdsb2JTdHJlYW1TeW5jLFxuICAgIHN0cmVhbVN5bmMsXG4gICAgZ2xvYkl0ZXJhdGUsXG4gICAgaXRlcmF0ZSxcbiAgICBnbG9iSXRlcmF0ZVN5bmMsXG4gICAgaXRlcmF0ZVN5bmMsXG4gICAgR2xvYixcbiAgICBoYXNNYWdpYyxcbiAgICBlc2NhcGUsXG4gICAgdW5lc2NhcGUsXG59KTtcbmdsb2IuZ2xvYiA9IGdsb2I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/glob/dist/esm/pattern.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pattern: () => (/* binding */ Pattern)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\");\n// this is just a very light wrapper around 2 arrays with an offset index\n\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0 ?\n                    this.isAbsolute() ?\n                        this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ?\n            this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ?\n            this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ?\n            this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?\n            p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\n//# sourceMappingURL=pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELCtDQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWtlcGluMnIvRG9jdW1lbnRzL3Byb2plY3RzL21ha2VwaW4yci5naXRodWIuaW8vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vcGF0dGVybi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIGlzIGp1c3QgYSB2ZXJ5IGxpZ2h0IHdyYXBwZXIgYXJvdW5kIDIgYXJyYXlzIHdpdGggYW4gb2Zmc2V0IGluZGV4XG5pbXBvcnQgeyBHTE9CU1RBUiB9IGZyb20gJ21pbmltYXRjaCc7XG5jb25zdCBpc1BhdHRlcm5MaXN0ID0gKHBsKSA9PiBwbC5sZW5ndGggPj0gMTtcbmNvbnN0IGlzR2xvYkxpc3QgPSAoZ2wpID0+IGdsLmxlbmd0aCA+PSAxO1xuLyoqXG4gKiBBbiBpbW11dGFibGUtaXNoIHZpZXcgb24gYW4gYXJyYXkgb2YgZ2xvYiBwYXJ0cyBhbmQgdGhlaXIgcGFyc2VkXG4gKiByZXN1bHRzXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXR0ZXJuIHtcbiAgICAjcGF0dGVybkxpc3Q7XG4gICAgI2dsb2JMaXN0O1xuICAgICNpbmRleDtcbiAgICBsZW5ndGg7XG4gICAgI3BsYXRmb3JtO1xuICAgICNyZXN0O1xuICAgICNnbG9iU3RyaW5nO1xuICAgICNpc0RyaXZlO1xuICAgICNpc1VOQztcbiAgICAjaXNBYnNvbHV0ZTtcbiAgICAjZm9sbG93R2xvYnN0YXIgPSB0cnVlO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5MaXN0LCBnbG9iTGlzdCwgaW5kZXgsIHBsYXRmb3JtKSB7XG4gICAgICAgIGlmICghaXNQYXR0ZXJuTGlzdChwYXR0ZXJuTGlzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VtcHR5IHBhdHRlcm4gbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNHbG9iTGlzdChnbG9iTGlzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VtcHR5IGdsb2IgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iTGlzdC5sZW5ndGggIT09IHBhdHRlcm5MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzbWF0Y2hlZCBwYXR0ZXJuIGxpc3QgYW5kIGdsb2IgbGlzdCBsZW5ndGhzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBwYXR0ZXJuTGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BhdHRlcm5MaXN0ID0gcGF0dGVybkxpc3Q7XG4gICAgICAgIHRoaXMuI2dsb2JMaXN0ID0gZ2xvYkxpc3Q7XG4gICAgICAgIHRoaXMuI2luZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuI3BsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIC8vIG5vcm1hbGl6ZSByb290IGVudHJpZXMgb2YgYWJzb2x1dGUgcGF0dGVybnMgb24gaW5pdGlhbCBjcmVhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuI2luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjOiA9PiBbJ2M6LyddXG4gICAgICAgICAgICAvLyBDOi8gPT4gWydDOi8nXVxuICAgICAgICAgICAgLy8gQzoveCA9PiBbJ0M6LycsICd4J11cbiAgICAgICAgICAgIC8vIC8vaG9zdC9zaGFyZSA9PiBbJy8vaG9zdC9zaGFyZS8nXVxuICAgICAgICAgICAgLy8gLy9ob3N0L3NoYXJlLyA9PiBbJy8vaG9zdC9zaGFyZS8nXVxuICAgICAgICAgICAgLy8gLy9ob3N0L3NoYXJlL3ggPT4gWycvL2hvc3Qvc2hhcmUvJywgJ3gnXVxuICAgICAgICAgICAgLy8gL2V0YyA9PiBbJy8nLCAnZXRjJ11cbiAgICAgICAgICAgIC8vIC8gPT4gWycvJ11cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVU5DKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAnJyAvICcnIC8gJ2hvc3QnIC8gJ3NoYXJlJ1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwMCwgcDEsIHAyLCBwMywgLi4ucHJlc3RdID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgICAgICAgICAgY29uc3QgW2cwLCBnMSwgZzIsIGczLCAuLi5ncmVzdF0gPSB0aGlzLiNnbG9iTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAocHJlc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZHMgaW4gL1xuICAgICAgICAgICAgICAgICAgICBwcmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBncmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwID0gW3AwLCBwMSwgcDIsIHAzLCAnJ10uam9pbignLycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBbZzAsIGcxLCBnMiwgZzMsICcnXS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGF0dGVybkxpc3QgPSBbcCwgLi4ucHJlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2dsb2JMaXN0ID0gW2csIC4uLmdyZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuI3BhdHRlcm5MaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNEcml2ZSgpIHx8IHRoaXMuaXNBYnNvbHV0ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3AxLCAuLi5wcmVzdF0gPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgICAgICAgICBjb25zdCBbZzEsIC4uLmdyZXN0XSA9IHRoaXMuI2dsb2JMaXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcmVzdFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kcyBpbiAvXG4gICAgICAgICAgICAgICAgICAgIHByZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGdyZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwMSArICcvJztcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gZzEgKyAnLyc7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGF0dGVybkxpc3QgPSBbcCwgLi4ucHJlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2dsb2JMaXN0ID0gW2csIC4uLmdyZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuI3BhdHRlcm5MaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgZW50cnkgaW4gdGhlIHBhcnNlZCBsaXN0IG9mIHBhdHRlcm5zXG4gICAgICovXG4gICAgcGF0dGVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBvZiBpZiBwYXR0ZXJuKCkgcmV0dXJucyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGlzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgb2YgaWYgcGF0dGVybigpIHJldHVybnMgR0xPQlNUQVJcbiAgICAgKi9cbiAgICBpc0dsb2JzdGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdID09PSBHTE9CU1RBUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiBwYXR0ZXJuKCkgcmV0dXJucyBhIHJlZ2V4cFxuICAgICAqL1xuICAgIGlzUmVnRXhwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgLy1qb2luZWQgc2V0IG9mIGdsb2IgcGFydHMgdGhhdCBtYWtlIHVwIHRoaXMgcGF0dGVyblxuICAgICAqL1xuICAgIGdsb2JTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZ2xvYlN0cmluZyA9XG4gICAgICAgICAgICB0aGlzLiNnbG9iU3RyaW5nIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuI2luZGV4ID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Fic29sdXRlKCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZ2xvYkxpc3RbMF0gKyB0aGlzLiNnbG9iTGlzdC5zbGljZSgxKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy4jZ2xvYkxpc3Quam9pbignLycpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy4jZ2xvYkxpc3Quc2xpY2UodGhpcy4jaW5kZXgpLmpvaW4oJy8nKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZXJlIGFyZSBtb3JlIHBhdHRlcm4gcGFydHMgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgKi9cbiAgICBoYXNNb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiB0aGlzLiNpbmRleCArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyIHRoaXMgcGFydCwgb3IgbnVsbCBpZiB0aGlzIGlzIHRoZSBlbmRcbiAgICAgKi9cbiAgICByZXN0KCkge1xuICAgICAgICBpZiAodGhpcy4jcmVzdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3Q7XG4gICAgICAgIGlmICghdGhpcy5oYXNNb3JlKCkpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3Jlc3QgPSBudWxsKTtcbiAgICAgICAgdGhpcy4jcmVzdCA9IG5ldyBQYXR0ZXJuKHRoaXMuI3BhdHRlcm5MaXN0LCB0aGlzLiNnbG9iTGlzdCwgdGhpcy4jaW5kZXggKyAxLCB0aGlzLiNwbGF0Zm9ybSk7XG4gICAgICAgIHRoaXMuI3Jlc3QuI2lzQWJzb2x1dGUgPSB0aGlzLiNpc0Fic29sdXRlO1xuICAgICAgICB0aGlzLiNyZXN0LiNpc1VOQyA9IHRoaXMuI2lzVU5DO1xuICAgICAgICB0aGlzLiNyZXN0LiNpc0RyaXZlID0gdGhpcy4jaXNEcml2ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHBhdHRlcm4gcmVwcmVzZW50cyBhIC8vdW5jL3BhdGgvIG9uIHdpbmRvd3NcbiAgICAgKi9cbiAgICBpc1VOQygpIHtcbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzVU5DICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy4jaXNVTkNcbiAgICAgICAgICAgIDogKHRoaXMuI2lzVU5DID1cbiAgICAgICAgICAgICAgICB0aGlzLiNwbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNpbmRleCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBwbFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcGxbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwbFsyXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgISFwbFsyXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGxbM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICEhcGxbM10pO1xuICAgIH1cbiAgICAvLyBwYXR0ZXJuIGxpa2UgQzovLi4uXG4gICAgLy8gc3BsaXQgPSBbJ0M6JywgLi4uXVxuICAgIC8vIFhYWDogd291bGQgYmUgbmljZSB0byBoYW5kbGUgcGF0dGVybnMgbGlrZSBgYzoqYCB0byB0ZXN0IHRoZSBjd2RcbiAgICAvLyBpbiBjOiBmb3IgKiwgYnV0IEkgZG9uJ3Qga25vdyBvZiBhIHdheSB0byBldmVuIGZpZ3VyZSBvdXQgd2hhdCB0aGF0XG4gICAgLy8gY3dkIGlzIHdpdGhvdXQgYWN0dWFsbHkgY2hkaXInaW5nIGludG8gaXQ/XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBhIGRyaXZlIGxldHRlciBvbiBXaW5kb3dzXG4gICAgICovXG4gICAgaXNEcml2ZSgpIHtcbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzRHJpdmUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLiNpc0RyaXZlXG4gICAgICAgICAgICA6ICh0aGlzLiNpc0RyaXZlID1cbiAgICAgICAgICAgICAgICB0aGlzLiNwbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNpbmRleCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBsWzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBsWzBdKSk7XG4gICAgfVxuICAgIC8vIHBhdHRlcm4gPSAnLycgb3IgJy8uLi4nIG9yICcveC8uLi4nXG4gICAgLy8gc3BsaXQgPSBbJycsICcnXSBvciBbJycsIC4uLl0gb3IgWycnLCAneCcsIC4uLl1cbiAgICAvLyBEcml2ZSBhbmQgVU5DIGJvdGggY29uc2lkZXJlZCBhYnNvbHV0ZSBvbiB3aW5kb3dzXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcGF0dGVybiBpcyByb290ZWQgb24gYW4gYWJzb2x1dGUgcGF0aFxuICAgICAqL1xuICAgIGlzQWJzb2x1dGUoKSB7XG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc0Fic29sdXRlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy4jaXNBYnNvbHV0ZVxuICAgICAgICAgICAgOiAodGhpcy4jaXNBYnNvbHV0ZSA9XG4gICAgICAgICAgICAgICAgKHBsWzBdID09PSAnJyAmJiBwbC5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJpdmUoKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVU5DKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25zdW1lIHRoZSByb290IG9mIHRoZSBwYXR0ZXJuLCBhbmQgcmV0dXJuIGl0XG4gICAgICovXG4gICAgcm9vdCgpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuI3BhdHRlcm5MaXN0WzBdO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBwID09PSAnc3RyaW5nJyAmJiB0aGlzLmlzQWJzb2x1dGUoKSAmJiB0aGlzLiNpbmRleCA9PT0gMCkgP1xuICAgICAgICAgICAgcFxuICAgICAgICAgICAgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IGdsb2JzdGFyIHBhdHRlcm4gaXMgYWxsb3dlZCB0byBmb2xsb3dcbiAgICAgKiBhIHN5bWJvbGljIGxpbmsuXG4gICAgICovXG4gICAgY2hlY2tGb2xsb3dHbG9ic3RhcigpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy4jaW5kZXggPT09IDAgfHxcbiAgICAgICAgICAgICF0aGlzLmlzR2xvYnN0YXIoKSB8fFxuICAgICAgICAgICAgIXRoaXMuI2ZvbGxvd0dsb2JzdGFyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayB0aGF0IHRoZSBjdXJyZW50IGdsb2JzdGFyIHBhdHRlcm4gaXMgZm9sbG93aW5nIGEgc3ltYm9saWMgbGlua1xuICAgICAqL1xuICAgIG1hcmtGb2xsb3dHbG9ic3RhcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2luZGV4ID09PSAwIHx8ICF0aGlzLmlzR2xvYnN0YXIoKSB8fCAhdGhpcy4jZm9sbG93R2xvYnN0YXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuI2ZvbGxvd0dsb2JzdGFyID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/processor.js":
/*!*************************************************!*\
  !*** ./node_modules/glob/dist/esm/processor.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HasWalkedCache: () => (/* binding */ HasWalkedCache),\n/* harmony export */   MatchRecord: () => (/* binding */ MatchRecord),\n/* harmony export */   Processor: () => (/* binding */ Processor),\n/* harmony export */   SubWalks: () => (/* binding */ SubWalks)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\");\n// synchronous utility for filtering entries and calculating subwalks\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache =\n            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined ?\n                    this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWtlcGluMnIvRG9jdW1lbnRzL3Byb2plY3RzL21ha2VwaW4yci5naXRodWIuaW8vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vcHJvY2Vzc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN5bmNocm9ub3VzIHV0aWxpdHkgZm9yIGZpbHRlcmluZyBlbnRyaWVzIGFuZCBjYWxjdWxhdGluZyBzdWJ3YWxrc1xuaW1wb3J0IHsgR0xPQlNUQVIgfSBmcm9tICdtaW5pbWF0Y2gnO1xuLyoqXG4gKiBBIGNhY2hlIG9mIHdoaWNoIHBhdHRlcm5zIGhhdmUgYmVlbiBwcm9jZXNzZWQgZm9yIGEgZ2l2ZW4gUGF0aFxuICovXG5leHBvcnQgY2xhc3MgSGFzV2Fsa2VkQ2FjaGUge1xuICAgIHN0b3JlO1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlID0gbmV3IE1hcCgpKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIYXNXYWxrZWRDYWNoZShuZXcgTWFwKHRoaXMuc3RvcmUpKTtcbiAgICB9XG4gICAgaGFzV2Fsa2VkKHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXQodGFyZ2V0LmZ1bGxwYXRoKCkpPy5oYXMocGF0dGVybi5nbG9iU3RyaW5nKCkpO1xuICAgIH1cbiAgICBzdG9yZVdhbGtlZCh0YXJnZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0YXJnZXQuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5zdG9yZS5nZXQoZnVsbHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgY2FjaGVkLmFkZChwYXR0ZXJuLmdsb2JTdHJpbmcoKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0KGZ1bGxwYXRoLCBuZXcgU2V0KFtwYXR0ZXJuLmdsb2JTdHJpbmcoKV0pKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcmVjb3JkIG9mIHdoaWNoIHBhdGhzIGhhdmUgYmVlbiBtYXRjaGVkIGluIGEgZ2l2ZW4gd2FsayBzdGVwLFxuICogYW5kIHdoZXRoZXIgdGhleSBvbmx5IGFyZSBjb25zaWRlcmVkIGEgbWF0Y2ggaWYgdGhleSBhcmUgYSBkaXJlY3RvcnksXG4gKiBhbmQgd2hldGhlciB0aGVpciBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIHNob3VsZCBiZSByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdGNoUmVjb3JkIHtcbiAgICBzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICBhZGQodGFyZ2V0LCBhYnNvbHV0ZSwgaWZEaXIpIHtcbiAgICAgICAgY29uc3QgbiA9IChhYnNvbHV0ZSA/IDIgOiAwKSB8IChpZkRpciA/IDEgOiAwKTtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuc3RvcmUuZ2V0KHRhcmdldCk7XG4gICAgICAgIHRoaXMuc3RvcmUuc2V0KHRhcmdldCwgY3VycmVudCA9PT0gdW5kZWZpbmVkID8gbiA6IG4gJiBjdXJyZW50KTtcbiAgICB9XG4gICAgLy8gbWF0Y2gsIGFic29sdXRlLCBpZmRpclxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zdG9yZS5lbnRyaWVzKCldLm1hcCgoW3BhdGgsIG5dKSA9PiBbXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgISEobiAmIDIpLFxuICAgICAgICAgICAgISEobiAmIDEpLFxuICAgICAgICBdKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwYXR0ZXJucyB0aGF0IG11c3QgYmUgcHJvY2Vzc2VkIGluIGEgc3Vic2VxdWVudCBzdGVwXG4gKiBmb3IgYSBnaXZlbiBwYXRoLlxuICovXG5leHBvcnQgY2xhc3MgU3ViV2Fsa3Mge1xuICAgIHN0b3JlID0gbmV3IE1hcCgpO1xuICAgIGFkZCh0YXJnZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCF0YXJnZXQuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3RvcmUuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICBpZiAoIXN1YnMuZmluZChwID0+IHAuZ2xvYlN0cmluZygpID09PSBwYXR0ZXJuLmdsb2JTdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2gocGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdG9yZS5zZXQodGFyZ2V0LCBbcGF0dGVybl0pO1xuICAgIH1cbiAgICBnZXQodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN0b3JlLmdldCh0YXJnZXQpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFzdWJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRpbmcgdG8gd2FsayB1bmtub3duIHBhdGgnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gc3VicztcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cygpLm1hcChrID0+IFtrLCB0aGlzLnN0b3JlLmdldChrKV0pO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuc3RvcmUua2V5cygpXS5maWx0ZXIodCA9PiB0LmNhblJlYWRkaXIoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgY2xhc3MgdGhhdCBwcm9jZXNzZXMgcGF0dGVybnMgZm9yIGEgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBIYW5kbGVzIGNoaWxkIGVudHJ5IGZpbHRlcmluZywgYW5kIGRldGVybWluaW5nIHdoZXRoZXIgYSBwYXRoJ3NcbiAqIGRpcmVjdG9yeSBjb250ZW50cyBtdXN0IGJlIHJlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9jZXNzb3Ige1xuICAgIGhhc1dhbGtlZENhY2hlO1xuICAgIG1hdGNoZXMgPSBuZXcgTWF0Y2hSZWNvcmQoKTtcbiAgICBzdWJ3YWxrcyA9IG5ldyBTdWJXYWxrcygpO1xuICAgIHBhdHRlcm5zO1xuICAgIGZvbGxvdztcbiAgICBkb3Q7XG4gICAgb3B0cztcbiAgICBjb25zdHJ1Y3RvcihvcHRzLCBoYXNXYWxrZWRDYWNoZSkge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmZvbGxvdyA9ICEhb3B0cy5mb2xsb3c7XG4gICAgICAgIHRoaXMuZG90ID0gISFvcHRzLmRvdDtcbiAgICAgICAgdGhpcy5oYXNXYWxrZWRDYWNoZSA9XG4gICAgICAgICAgICBoYXNXYWxrZWRDYWNoZSA/IGhhc1dhbGtlZENhY2hlLmNvcHkoKSA6IG5ldyBIYXNXYWxrZWRDYWNoZSgpO1xuICAgIH1cbiAgICBwcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdTZXQgPSBwYXR0ZXJucy5tYXAocCA9PiBbdGFyZ2V0LCBwXSk7XG4gICAgICAgIC8vIG1hcCBvZiBwYXRocyB0byB0aGUgbWFnaWMtc3RhcnRpbmcgc3Vid2Fsa3MgdGhleSBuZWVkIHRvIHdhbGtcbiAgICAgICAgLy8gZmlyc3QgaXRlbSBpbiBwYXR0ZXJucyBpcyB0aGUgZmlsdGVyXG4gICAgICAgIGZvciAobGV0IFt0LCBwYXR0ZXJuXSBvZiBwcm9jZXNzaW5nU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dhbGtlZENhY2hlLnN0b3JlV2Fsa2VkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHBhdHRlcm4ucm9vdCgpO1xuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwYXR0ZXJuLmlzQWJzb2x1dGUoKSAmJiB0aGlzLm9wdHMuYWJzb2x1dGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgLy8gc3RhcnQgYWJzb2x1dGUgcGF0dGVybnMgYXQgcm9vdFxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICB0ID0gdC5yZXNvbHZlKHJvb3QgPT09ICcvJyAmJiB0aGlzLm9wdHMucm9vdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLnJvb3RcbiAgICAgICAgICAgICAgICAgICAgOiByb290KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gcGF0dGVybi5yZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0LmlzRU5PRU5UKCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgIGxldCByZXN0O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgKHAgPSBwYXR0ZXJuLnBhdHRlcm4oKSkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgKHJlc3QgPSBwYXR0ZXJuLnJlc3QoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdC5yZXNvbHZlKHApO1xuICAgICAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXN0O1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHBhdHRlcm4ucGF0dGVybigpO1xuICAgICAgICAgICAgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXYWxrZWRDYWNoZS5oYXNXYWxrZWQodCwgcGF0dGVybikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzV2Fsa2VkQ2FjaGUuc3RvcmVXYWxrZWQodCwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cgd2UgaGF2ZSBlaXRoZXIgYSBmaW5hbCBzdHJpbmcgZm9yIGEga25vd24gZW50cnksXG4gICAgICAgICAgICAvLyBtb3JlIHN0cmluZ3MgZm9yIGFuIHVua25vd24gZW50cnksXG4gICAgICAgICAgICAvLyBvciBhIHBhdHRlcm4gc3RhcnRpbmcgd2l0aCBtYWdpYywgbW91bnRlZCBvbiB0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIG11c3Qgbm90IGJlIGZpbmFsIGVudHJ5LCBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIGNvbmNhdGVuYXRlZCBpdCBlYXJsaWVyLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlmRGlyID0gcCA9PT0gJy4uJyB8fCBwID09PSAnJyB8fCBwID09PSAnLic7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0LnJlc29sdmUocCksIGFic29sdXRlLCBpZkRpcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHJlc3QsIG1hdGNoIGFuZCBzdWJ3YWxrIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAvLyBpZiByZXN0LCBwcm9jZXNzIHJlc3QgYW5kIHN1YndhbGsgcGF0dGVyblxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBzeW1saW5rLCBidXQgd2UgZGlkbid0IGdldCBoZXJlIGJ5IHdheSBvZiBhXG4gICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgbWF0Y2ggKG1lYW5pbmcgaXQncyB0aGUgZmlyc3QgdGltZSBUSElTIGdsb2JzdGFyXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRyYXZlcnNlZCBhIHN5bWxpbmspLCB0aGVuIHdlIGZvbGxvdyBpdC4gT3RoZXJ3aXNlLCBzdG9wLlxuICAgICAgICAgICAgICAgIGlmICghdC5pc1N5bWJvbGljTGluaygpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sbG93IHx8XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uY2hlY2tGb2xsb3dHbG9ic3RhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBycCA9IHJlc3Q/LnBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBycmVzdCA9IHJlc3Q/LnJlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3QgfHwgKChycCA9PT0gJycgfHwgcnAgPT09ICcuJykgJiYgIXJyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IEhBUyB0byBiZSBhIGRpciBpZiBpdCBlbmRzIGluICoqLyBvciAqKi8uXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBlbmRpbmcgaW4gKiogd2lsbCBtYXRjaCBmaWxlcyBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHQsIGFic29sdXRlLCBycCA9PT0gJycgfHwgcnAgPT09ICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnAgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgbWVhbiB5b3UncmUgbWF0Y2hpbmcgKiovLi4gYXQgdGhlIGZzIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm8gdGhhbmtzLCBJJ20gbm90IGdvbm5hIHRlc3QgdGhhdCBzcGVjaWZpYyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cCA9IHQucGFyZW50IHx8IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFycmVzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHRwLCBhYnNvbHV0ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNXYWxrZWRDYWNoZS5oYXNXYWxrZWQodHAsIHJyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHRwLCBycmVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQodCwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN1YndhbGtUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ3YWxrcy5rZXlzKCk7XG4gICAgfVxuICAgIGNoaWxkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3Nvcih0aGlzLm9wdHMsIHRoaXMuaGFzV2Fsa2VkQ2FjaGUpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gYSBuZXcgUHJvY2Vzc29yIGNvbnRhaW5pbmcgdGhlIHN1YndhbGtzIGZvciBlYWNoXG4gICAgLy8gY2hpbGQgZW50cnksIGFuZCBhIHNldCBvZiBtYXRjaGVzLCBhbmRcbiAgICAvLyBhIGhhc1dhbGtlZENhY2hlIHRoYXQncyBhIGNvcHkgb2YgdGhpcyBvbmVcbiAgICAvLyB0aGVuIHdlJ3JlIGdvaW5nIHRvIGNhbGxcbiAgICBmaWx0ZXJFbnRyaWVzKHBhcmVudCwgZW50cmllcykge1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IHRoaXMuc3Vid2Fsa3MuZ2V0KHBhcmVudCk7XG4gICAgICAgIC8vIHB1dCBtYXRjaGVzIGFuZCBlbnRyeSB3YWxrcyBpbnRvIHRoZSByZXN1bHRzIHByb2Nlc3NvclxuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5jaGlsZCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwYXR0ZXJuLmlzQWJzb2x1dGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0dGVybi5wYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnRlc3RHbG9ic3RhcihlLCBwYXR0ZXJuLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy50ZXN0UmVnRXhwKGUsIHAsIHJlc3QsIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudGVzdFN0cmluZyhlLCBwLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICB0ZXN0R2xvYnN0YXIoZSwgcGF0dGVybiwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZG90IHx8ICFlLm5hbWUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4uaGFzTW9yZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlLCBhYnNvbHV0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gZm9sbG93IG1vZGUgb3IgaXQncyBub3QgYSBzeW1saW5rLCBqdXN0IGtlZXBcbiAgICAgICAgICAgICAgICAvLyB0ZXN0aW5nIHRoZSBzYW1lIHBhdHRlcm4uIElmIHRoZXJlJ3MgbW9yZSBhZnRlciB0aGUgZ2xvYnN0YXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB0aGlzIHN5bWxpbmsgY29uc3VtZXMgdGhlIGdsb2JzdGFyLiBJZiBub3QsIHRoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gZm9sbG93IGF0IG1vc3QgT05FIHN5bWxpbmsgYWxvbmcgdGhlIHdheSwgc28gd2UgbWFyayBpdCwgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGNoZWNrcyB0byBlbnN1cmUgdGhhdCBpdCB3YXNuJ3QgYWxyZWFkeSBtYXJrZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sbG93IHx8ICFlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCAmJiBwYXR0ZXJuLmNoZWNrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybi5tYXJrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIE5FWFQgdGhpbmcgbWF0Y2hlcyB0aGlzIGVudHJ5LCB0aGVuIGFsc28gYWRkXG4gICAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgY29uc3QgcnAgPSByZXN0LnBhdHRlcm4oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnAgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgLy8gZG90cyBhbmQgZW1wdHkgd2VyZSBoYW5kbGVkIGFscmVhZHlcbiAgICAgICAgICAgICAgICBycCAhPT0gJy4uJyAmJlxuICAgICAgICAgICAgICAgIHJwICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgIHJwICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RTdHJpbmcoZSwgcnAsIHJlc3QucmVzdCgpLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChycCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGVwID0gZS5wYXJlbnQgfHwgZTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGVwLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0UmVnRXhwKGUsIHJwLCByZXN0LnJlc3QoKSwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRlc3RSZWdFeHAoZSwgcCwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKCFwLnRlc3QoZS5uYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUsIGFic29sdXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCByZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXN0U3RyaW5nKGUsIHAsIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4/XG4gICAgICAgIGlmICghZS5pc05hbWVkKHApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSwgYWJzb2x1dGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHJlc3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/walker.js":
/*!**********************************************!*\
  !*** ./node_modules/glob/dist/esm/walker.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobStream: () => (/* binding */ GlobStream),\n/* harmony export */   GlobUtil: () => (/* binding */ GlobUtil),\n/* harmony export */   GlobWalker: () => (/* binding */ GlobWalker)\n/* harmony export */ });\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/esm/ignore.js\");\n/* harmony import */ var _processor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/glob/dist/esm/processor.js\");\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\n\n\n\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new _ignore_js__WEBPACK_IMPORTED_MODULE_1__.Ignore([ignore], opts)\n    : Array.isArray(ignore) ? new _ignore_js__WEBPACK_IMPORTED_MODULE_1__.Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    includeChildMatches;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches &&\n                typeof this.#ignore.add !== 'function') {\n                const m = 'cannot ignore child matches, ignore lacks add() method.';\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */\n            if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n            /* c8 ignore stop */\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return (e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            (!this.opts.nodir ||\n                !this.opts.follow ||\n                !e.isSymbolicLink() ||\n                !e.realpathCached()?.isDirectory()) &&\n            !this.#ignored(e)) ?\n            e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n                '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new _processor_js__WEBPACK_IMPORTED_MODULE_2__.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new _processor_js__WEBPACK_IMPORTED_MODULE_2__.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nclass GlobWalker extends GlobUtil {\n    matches = new Set();\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nclass GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new minipass__WEBPACK_IMPORTED_MODULE_0__.Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\n//# sourceMappingURL=walker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS93YWxrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDQztBQUNNO0FBQzNDLHNFQUFzRSw4Q0FBTTtBQUM1RSxrQ0FBa0MsOENBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvREFBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0RBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQVE7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWtlcGluMnIvRG9jdW1lbnRzL3Byb2plY3RzL21ha2VwaW4yci5naXRodWIuaW8vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vd2Fsa2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2luZ2xlLXVzZSB1dGlsaXR5IGNsYXNzZXMgdG8gcHJvdmlkZSBmdW5jdGlvbmFsaXR5IHRvIHRoZSB7QGxpbmsgR2xvYn1cbiAqIG1ldGhvZHMuXG4gKlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBNaW5pcGFzcyB9IGZyb20gJ21pbmlwYXNzJztcbmltcG9ydCB7IElnbm9yZSB9IGZyb20gJy4vaWdub3JlLmpzJztcbmltcG9ydCB7IFByb2Nlc3NvciB9IGZyb20gJy4vcHJvY2Vzc29yLmpzJztcbmNvbnN0IG1ha2VJZ25vcmUgPSAoaWdub3JlLCBvcHRzKSA9PiB0eXBlb2YgaWdub3JlID09PSAnc3RyaW5nJyA/IG5ldyBJZ25vcmUoW2lnbm9yZV0sIG9wdHMpXG4gICAgOiBBcnJheS5pc0FycmF5KGlnbm9yZSkgPyBuZXcgSWdub3JlKGlnbm9yZSwgb3B0cylcbiAgICAgICAgOiBpZ25vcmU7XG4vKipcbiAqIGJhc2ljIHdhbGtpbmcgdXRpbGl0aWVzIHRoYXQgYWxsIHRoZSBnbG9iIHdhbGtlciB0eXBlcyB1c2VcbiAqL1xuZXhwb3J0IGNsYXNzIEdsb2JVdGlsIHtcbiAgICBwYXRoO1xuICAgIHBhdHRlcm5zO1xuICAgIG9wdHM7XG4gICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBhYm9ydGVkID0gZmFsc2U7XG4gICAgI29uUmVzdW1lID0gW107XG4gICAgI2lnbm9yZTtcbiAgICAjc2VwO1xuICAgIHNpZ25hbDtcbiAgICBtYXhEZXB0aDtcbiAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy4jc2VwID0gIW9wdHMucG9zaXggJiYgb3B0cy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdcXFxcJyA6ICcvJztcbiAgICAgICAgdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzID0gb3B0cy5pbmNsdWRlQ2hpbGRNYXRjaGVzICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdHMuaWdub3JlIHx8ICF0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuI2lnbm9yZSA9IG1ha2VJZ25vcmUob3B0cy5pZ25vcmUgPz8gW10sIG9wdHMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy4jaWdub3JlLmFkZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSAnY2Fubm90IGlnbm9yZSBjaGlsZCBtYXRjaGVzLCBpZ25vcmUgbGFja3MgYWRkKCkgbWV0aG9kLic7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlnbm9yZSwgYWx3YXlzIHNldCB3aXRoIG1heERlcHRoLCBidXQgaXQncyBvcHRpb25hbCBvbiB0aGVcbiAgICAgICAgLy8gR2xvYk9wdGlvbnMgdHlwZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9IG9wdHMubWF4RGVwdGggfHwgSW5maW5pdHk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChvcHRzLnNpZ25hbCkge1xuICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBvcHRzLnNpZ25hbDtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI29uUmVzdW1lLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjaWdub3JlZChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZW4uaGFzKHBhdGgpIHx8ICEhdGhpcy4jaWdub3JlPy5pZ25vcmVkPy4ocGF0aCk7XG4gICAgfVxuICAgICNjaGlsZHJlbklnbm9yZWQocGF0aCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNpZ25vcmU/LmNoaWxkcmVuSWdub3JlZD8uKHBhdGgpO1xuICAgIH1cbiAgICAvLyBiYWNrcHJlc3N1cmUgbWVjaGFuaXNtXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5wYXVzZWQgJiYgKGZuID0gdGhpcy4jb25SZXN1bWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25SZXN1bWUoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNvblJlc3VtZS5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyB0aGUgcmVxdWlzaXRlIHJlYWxwYXRoL3N0YXQgY2hlY2tpbmcsIGFuZCByZXR1cm4gdGhlIHBhdGhcbiAgICAvLyB0byBhZGQgb3IgdW5kZWZpbmVkIHRvIGZpbHRlciBpdCBvdXQuXG4gICAgYXN5bmMgbWF0Y2hDaGVjayhlLCBpZkRpcikge1xuICAgICAgICBpZiAoaWZEaXIgJiYgdGhpcy5vcHRzLm5vZGlyKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJwYztcbiAgICAgICAgaWYgKHRoaXMub3B0cy5yZWFscGF0aCkge1xuICAgICAgICAgICAgcnBjID0gZS5yZWFscGF0aENhY2hlZCgpIHx8IChhd2FpdCBlLnJlYWxwYXRoKCkpO1xuICAgICAgICAgICAgaWYgKCFycGMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGUgPSBycGM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZFN0YXQgPSBlLmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0O1xuICAgICAgICBjb25zdCBzID0gbmVlZFN0YXQgPyBhd2FpdCBlLmxzdGF0KCkgOiBlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmZvbGxvdyAmJiB0aGlzLm9wdHMubm9kaXIgJiYgcz8uaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgcy5yZWFscGF0aCgpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQuaXNVbmtub3duKCkgfHwgdGhpcy5vcHRzLnN0YXQpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGFyZ2V0LmxzdGF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoQ2hlY2tUZXN0KHMsIGlmRGlyKTtcbiAgICB9XG4gICAgbWF0Y2hDaGVja1Rlc3QoZSwgaWZEaXIpIHtcbiAgICAgICAgcmV0dXJuIChlICYmXG4gICAgICAgICAgICAodGhpcy5tYXhEZXB0aCA9PT0gSW5maW5pdHkgfHwgZS5kZXB0aCgpIDw9IHRoaXMubWF4RGVwdGgpICYmXG4gICAgICAgICAgICAoIWlmRGlyIHx8IGUuY2FuUmVhZGRpcigpKSAmJlxuICAgICAgICAgICAgKCF0aGlzLm9wdHMubm9kaXIgfHwgIWUuaXNEaXJlY3RvcnkoKSkgJiZcbiAgICAgICAgICAgICghdGhpcy5vcHRzLm5vZGlyIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMub3B0cy5mb2xsb3cgfHxcbiAgICAgICAgICAgICAgICAhZS5pc1N5bWJvbGljTGluaygpIHx8XG4gICAgICAgICAgICAgICAgIWUucmVhbHBhdGhDYWNoZWQoKT8uaXNEaXJlY3RvcnkoKSkgJiZcbiAgICAgICAgICAgICF0aGlzLiNpZ25vcmVkKGUpKSA/XG4gICAgICAgICAgICBlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbWF0Y2hDaGVja1N5bmMoZSwgaWZEaXIpIHtcbiAgICAgICAgaWYgKGlmRGlyICYmIHRoaXMub3B0cy5ub2RpcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBycGM7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucmVhbHBhdGgpIHtcbiAgICAgICAgICAgIHJwYyA9IGUucmVhbHBhdGhDYWNoZWQoKSB8fCBlLnJlYWxwYXRoU3luYygpO1xuICAgICAgICAgICAgaWYgKCFycGMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGUgPSBycGM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZFN0YXQgPSBlLmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0O1xuICAgICAgICBjb25zdCBzID0gbmVlZFN0YXQgPyBlLmxzdGF0U3luYygpIDogZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5mb2xsb3cgJiYgdGhpcy5vcHRzLm5vZGlyICYmIHM/LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHMucmVhbHBhdGhTeW5jKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQ/LmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5sc3RhdFN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaENoZWNrVGVzdChzLCBpZkRpcik7XG4gICAgfVxuICAgIG1hdGNoRmluaXNoKGUsIGFic29sdXRlKSB7XG4gICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyB3ZSBrbm93IHdlIGhhdmUgYW4gaWdub3JlIGlmIHRoaXMgaXMgZmFsc2UsIGJ1dCBUUyBkb2Vzbid0XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzICYmIHRoaXMuI2lnbm9yZT8uYWRkKSB7XG4gICAgICAgICAgICBjb25zdCBpZ24gPSBgJHtlLnJlbGF0aXZlUG9zaXgoKX0vKipgO1xuICAgICAgICAgICAgdGhpcy4jaWdub3JlLmFkZChpZ24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFicyA9IHRoaXMub3B0cy5hYnNvbHV0ZSA9PT0gdW5kZWZpbmVkID8gYWJzb2x1dGUgOiB0aGlzLm9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMuc2Vlbi5hZGQoZSk7XG4gICAgICAgIGNvbnN0IG1hcmsgPSB0aGlzLm9wdHMubWFyayAmJiBlLmlzRGlyZWN0b3J5KCkgPyB0aGlzLiNzZXAgOiAnJztcbiAgICAgICAgLy8gb2ssIHdlIGhhdmUgd2hhdCB3ZSBuZWVkIVxuICAgICAgICBpZiAodGhpcy5vcHRzLndpdGhGaWxlVHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hFbWl0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFicykge1xuICAgICAgICAgICAgY29uc3QgYWJzID0gdGhpcy5vcHRzLnBvc2l4ID8gZS5mdWxscGF0aFBvc2l4KCkgOiBlLmZ1bGxwYXRoKCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdChhYnMgKyBtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbCA9IHRoaXMub3B0cy5wb3NpeCA/IGUucmVsYXRpdmVQb3NpeCgpIDogZS5yZWxhdGl2ZSgpO1xuICAgICAgICAgICAgY29uc3QgcHJlID0gdGhpcy5vcHRzLmRvdFJlbGF0aXZlICYmICFyZWwuc3RhcnRzV2l0aCgnLi4nICsgdGhpcy4jc2VwKSA/XG4gICAgICAgICAgICAgICAgJy4nICsgdGhpcy4jc2VwXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2hFbWl0KCFyZWwgPyAnLicgKyBtYXJrIDogcHJlICsgcmVsICsgbWFyayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbWF0Y2goZSwgYWJzb2x1dGUsIGlmRGlyKSB7XG4gICAgICAgIGNvbnN0IHAgPSBhd2FpdCB0aGlzLm1hdGNoQ2hlY2soZSwgaWZEaXIpO1xuICAgICAgICBpZiAocClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hGaW5pc2gocCwgYWJzb2x1dGUpO1xuICAgIH1cbiAgICBtYXRjaFN5bmMoZSwgYWJzb2x1dGUsIGlmRGlyKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLm1hdGNoQ2hlY2tTeW5jKGUsIGlmRGlyKTtcbiAgICAgICAgaWYgKHApXG4gICAgICAgICAgICB0aGlzLm1hdGNoRmluaXNoKHAsIGFic29sdXRlKTtcbiAgICB9XG4gICAgd2Fsa0NCKHRhcmdldCwgcGF0dGVybnMsIGNiKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgbmV3IFByb2Nlc3Nvcih0aGlzLm9wdHMpLCBjYik7XG4gICAgfVxuICAgIHdhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBpZiAodGhpcy4jY2hpbGRyZW5JZ25vcmVkKHRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVzdW1lKCgpID0+IHRoaXMud2Fsa0NCMih0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IsIGNiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3NQYXR0ZXJucyh0YXJnZXQsIHBhdHRlcm5zKTtcbiAgICAgICAgLy8gZG9uZSBwcm9jZXNzaW5nLiAgYWxsIG9mIHRoZSBhYm92ZSBpcyBzeW5jLCBjYW4gYmUgYWJzdHJhY3RlZCBvdXQuXG4gICAgICAgIC8vIHN1YndhbGtzIGlzIGEgbWFwIG9mIHBhdGhzIHRvIHRoZSBlbnRyeSBmaWx0ZXJzIHRoZXkgbmVlZFxuICAgICAgICAvLyBtYXRjaGVzIGlzIGEgbWFwIG9mIHBhdGhzIHRvIFthYnNvbHV0ZSwgaWZEaXJdIHR1cGxlcy5cbiAgICAgICAgbGV0IHRhc2tzID0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLXRhc2tzID09PSAwKVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW20sIGFic29sdXRlLCBpZkRpcl0gb2YgcHJvY2Vzc29yLm1hdGNoZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaWdub3JlZChtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKG0sIGFic29sdXRlLCBpZkRpcikudGhlbigoKSA9PiBuZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBwcm9jZXNzb3Iuc3Vid2Fsa1RhcmdldHMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ICYmIHQuZGVwdGgoKSA+PSB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5DYWNoZWQgPSB0LnJlYWRkaXJDYWNoZWQoKTtcbiAgICAgICAgICAgIGlmICh0LmNhbGxlZFJlYWRkaXIoKSlcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtDQjModCwgY2hpbGRyZW5DYWNoZWQsIHByb2Nlc3NvciwgbmV4dCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0LnJlYWRkaXJDQigoXywgZW50cmllcykgPT4gdGhpcy53YWxrQ0IzKHQsIGVudHJpZXMsIHByb2Nlc3NvciwgbmV4dCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgd2Fsa0NCMyh0YXJnZXQsIGVudHJpZXMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc29yLmZpbHRlckVudHJpZXModGFyZ2V0LCBlbnRyaWVzKTtcbiAgICAgICAgbGV0IHRhc2tzID0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLXRhc2tzID09PSAwKVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW20sIGFic29sdXRlLCBpZkRpcl0gb2YgcHJvY2Vzc29yLm1hdGNoZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaWdub3JlZChtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKG0sIGFic29sdXRlLCBpZkRpcikudGhlbigoKSA9PiBuZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3RhcmdldCwgcGF0dGVybnNdIG9mIHByb2Nlc3Nvci5zdWJ3YWxrcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLmNoaWxkKCksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgd2Fsa0NCU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBuZXcgUHJvY2Vzc29yKHRoaXMub3B0cyksIGNiKTtcbiAgICB9XG4gICAgd2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBpZiAodGhpcy4jY2hpbGRyZW5JZ25vcmVkKHRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVzdW1lKCgpID0+IHRoaXMud2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucyk7XG4gICAgICAgIC8vIGRvbmUgcHJvY2Vzc2luZy4gIGFsbCBvZiB0aGUgYWJvdmUgaXMgc3luYywgY2FuIGJlIGFic3RyYWN0ZWQgb3V0LlxuICAgICAgICAvLyBzdWJ3YWxrcyBpcyBhIG1hcCBvZiBwYXRocyB0byB0aGUgZW50cnkgZmlsdGVycyB0aGV5IG5lZWRcbiAgICAgICAgLy8gbWF0Y2hlcyBpcyBhIG1hcCBvZiBwYXRocyB0byBbYWJzb2x1dGUsIGlmRGlyXSB0dXBsZXMuXG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm1hdGNoU3luYyhtLCBhYnNvbHV0ZSwgaWZEaXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBwcm9jZXNzb3Iuc3Vid2Fsa1RhcmdldHMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ICYmIHQuZGVwdGgoKSA+PSB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0LnJlYWRkaXJTeW5jKCk7XG4gICAgICAgICAgICB0aGlzLndhbGtDQjNTeW5jKHQsIGNoaWxkcmVuLCBwcm9jZXNzb3IsIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgd2Fsa0NCM1N5bmModGFyZ2V0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3Nvci5maWx0ZXJFbnRyaWVzKHRhcmdldCwgZW50cmllcyk7XG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm1hdGNoU3luYyhtLCBhYnNvbHV0ZSwgaWZEaXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3RhcmdldCwgcGF0dGVybnNdIG9mIHByb2Nlc3Nvci5zdWJ3YWxrcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLndhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3Nvci5jaGlsZCgpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdsb2JXYWxrZXIgZXh0ZW5kcyBHbG9iVXRpbCB7XG4gICAgbWF0Y2hlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICBzdXBlcihwYXR0ZXJucywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1hdGNoRW1pdChlKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSk7XG4gICAgfVxuICAgIGFzeW5jIHdhbGsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXRoLmxzdGF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndhbGtDQih0aGlzLnBhdGgsIHRoaXMucGF0dGVybnMsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqKHRoaXMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXModGhpcy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgfVxuICAgIHdhbGtTeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyB0aGlzLnNpZ25hbC5yZWFzb247XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aC5sc3RhdFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RoaW5nIGZvciB0aGUgY2FsbGJhY2sgdG8gZG8sIGJlY2F1c2UgdGhpcyBuZXZlciBwYXVzZXNcbiAgICAgICAgdGhpcy53YWxrQ0JTeW5jKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdsb2JTdHJlYW0gZXh0ZW5kcyBHbG9iVXRpbCB7XG4gICAgcmVzdWx0cztcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICBzdXBlcihwYXR0ZXJucywgcGF0aCwgb3B0cyk7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IG5ldyBNaW5pcGFzcyh7XG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuc2lnbmFsLFxuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdWx0cy5vbignZHJhaW4nLCAoKSA9PiB0aGlzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzLm9uKCdyZXN1bWUnLCAoKSA9PiB0aGlzLnJlc3VtZSgpKTtcbiAgICB9XG4gICAgbWF0Y2hFbWl0KGUpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRzLndyaXRlKGUpO1xuICAgICAgICBpZiAoIXRoaXMucmVzdWx0cy5mbG93aW5nKVxuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgICBzdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHRhcmdldC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmxzdGF0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQ0IodGFyZ2V0LCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB0aGlzLnJlc3VsdHMuZW5kKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhbGtDQih0YXJnZXQsIHRoaXMucGF0dGVybnMsICgpID0+IHRoaXMucmVzdWx0cy5lbmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cztcbiAgICB9XG4gICAgc3RyZWFtU3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoLmxzdGF0U3luYygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2Fsa0NCU3luYyh0aGlzLnBhdGgsIHRoaXMucGF0dGVybnMsICgpID0+IHRoaXMucmVzdWx0cy5lbmQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fsa2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/walker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/assert-valid-pattern.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/esm/assert-valid-pattern.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertValidPattern: () => (/* binding */ assertValidPattern)\n/* harmony export */ });\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21ha2VwaW4yci9Eb2N1bWVudHMvcHJvamVjdHMvbWFrZXBpbjJyLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NDtcbmV4cG9ydCBjb25zdCBhc3NlcnRWYWxpZFBhdHRlcm4gPSAocGF0dGVybikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJyk7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJyk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC12YWxpZC1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/assert-valid-pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/ast.js":
/*!******************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/esm/ast.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* binding */ AST)\n/* harmony export */ });\n/* harmony import */ var _brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brace-expressions.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/brace-expressions.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/unescape.js\");\n// parse a single path portion\n\n\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0,_brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2FzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNvRDtBQUNYO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLE1BQU0sZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBUTtBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWtlcGluMnIvRG9jdW1lbnRzL3Byb2plY3RzL21ha2VwaW4yci5naXRodWIuaW8vbm9kZV9tb2R1bGVzL2dsb2Ivbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2VzbS9hc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFyc2UgYSBzaW5nbGUgcGF0aCBwb3J0aW9uXG5pbXBvcnQgeyBwYXJzZUNsYXNzIH0gZnJvbSAnLi9icmFjZS1leHByZXNzaW9ucy5qcyc7XG5pbXBvcnQgeyB1bmVzY2FwZSB9IGZyb20gJy4vdW5lc2NhcGUuanMnO1xuY29uc3QgdHlwZXMgPSBuZXcgU2V0KFsnIScsICc/JywgJysnLCAnKicsICdAJ10pO1xuY29uc3QgaXNFeHRnbG9iVHlwZSA9IChjKSA9PiB0eXBlcy5oYXMoYyk7XG4vLyBQYXR0ZXJucyB0aGF0IGdldCBwcmVwZW5kZWQgdG8gYmluZCB0byB0aGUgc3RhcnQgb2YgZWl0aGVyIHRoZVxuLy8gZW50aXJlIHN0cmluZywgb3IganVzdCBhIHNpbmdsZSBwYXRoIHBvcnRpb24sIHRvIHByZXZlbnQgZG90c1xuLy8gYW5kL29yIHRyYXZlcnNhbCBwYXR0ZXJucywgd2hlbiBuZWVkZWQuXG4vLyBFeHRzIGRvbid0IG5lZWQgdGhlIF4gb3IgLyBiaXQsIGJlY2F1c2UgdGhlIHJvb3QgYmluZHMgdGhhdCBhbHJlYWR5LlxuY29uc3Qgc3RhcnROb1RyYXZlcnNhbCA9ICcoPyEoPzpefC8pXFxcXC5cXFxcLj8oPzokfC8pKSc7XG5jb25zdCBzdGFydE5vRG90ID0gJyg/IVxcXFwuKSc7XG4vLyBjaGFyYWN0ZXJzIHRoYXQgaW5kaWNhdGUgYSBzdGFydCBvZiBwYXR0ZXJuIG5lZWRzIHRoZSBcIm5vIGRvdHNcIiBiaXQsXG4vLyBiZWNhdXNlIGEgZG90ICptaWdodCogYmUgbWF0Y2hlZC4gKCBpcyBub3QgaW4gdGhlIGxpc3QsIGJlY2F1c2UgaW5cbi8vIHRoZSBjYXNlIG9mIGEgY2hpbGQgZXh0Z2xvYiwgaXQgd2lsbCBoYW5kbGUgdGhlIHByZXZlbnRpb24gaXRzZWxmLlxuY29uc3QgYWRkUGF0dGVyblN0YXJ0ID0gbmV3IFNldChbJ1snLCAnLiddKTtcbi8vIGNhc2VzIHdoZXJlIHRyYXZlcnNhbCBpcyBBLU9LLCBubyBkb3QgcHJldmVudGlvbiBuZWVkZWRcbmNvbnN0IGp1c3REb3RzID0gbmV3IFNldChbJy4uJywgJy4nXSk7XG5jb25zdCByZVNwZWNpYWxzID0gbmV3IFNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKTtcbmNvbnN0IHJlZ0V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vIHVzZSArIHdoZW4gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCAqc29tZXRoaW5nKiBtYXRjaGVzLCBiZWNhdXNlIHRoZSAqIGlzXG4vLyB0aGUgb25seSB0aGluZyBpbiB0aGUgcGF0aCBwb3J0aW9uLlxuY29uc3Qgc3Rhck5vRW1wdHkgPSBxbWFyayArICcrPyc7XG4vLyByZW1vdmUgdGhlIFxcIGNoYXJzIHRoYXQgd2UgYWRkZWQgaWYgd2UgZW5kIHVwIGRvaW5nIGEgbm9ubWFnaWMgY29tcGFyZVxuLy8gY29uc3QgZGVzbGFzaCA9IChzOiBzdHJpbmcpID0+IHMucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKVxuZXhwb3J0IGNsYXNzIEFTVCB7XG4gICAgdHlwZTtcbiAgICAjcm9vdDtcbiAgICAjaGFzTWFnaWM7XG4gICAgI3VmbGFnID0gZmFsc2U7XG4gICAgI3BhcnRzID0gW107XG4gICAgI3BhcmVudDtcbiAgICAjcGFyZW50SW5kZXg7XG4gICAgI25lZ3M7XG4gICAgI2ZpbGxlZE5lZ3MgPSBmYWxzZTtcbiAgICAjb3B0aW9ucztcbiAgICAjdG9TdHJpbmc7XG4gICAgLy8gc2V0IHRvIHRydWUgaWYgaXQncyBhbiBleHRnbG9iIHdpdGggbm8gY2hpbGRyZW5cbiAgICAvLyAod2hpY2ggcmVhbGx5IG1lYW5zIG9uZSBjaGlsZCBvZiAnJylcbiAgICAjZW1wdHlFeHQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwYXJlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvLyBleHRnbG9icyBhcmUgaW5oZXJlbnRseSBtYWdpY2FsXG4gICAgICAgIGlmICh0eXBlKVxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuI3Jvb3QgPSB0aGlzLiNwYXJlbnQgPyB0aGlzLiNwYXJlbnQuI3Jvb3QgOiB0aGlzO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gdGhpcy4jcm9vdCA9PT0gdGhpcyA/IG9wdGlvbnMgOiB0aGlzLiNyb290LiNvcHRpb25zO1xuICAgICAgICB0aGlzLiNuZWdzID0gdGhpcy4jcm9vdCA9PT0gdGhpcyA/IFtdIDogdGhpcy4jcm9vdC4jbmVncztcbiAgICAgICAgaWYgKHR5cGUgPT09ICchJyAmJiAhdGhpcy4jcm9vdC4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHRoaXMuI25lZ3MucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcGFyZW50SW5kZXggPSB0aGlzLiNwYXJlbnQgPyB0aGlzLiNwYXJlbnQuI3BhcnRzLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGdldCBoYXNNYWdpYygpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLiNoYXNNYWdpYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy4jcGFydHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocC50eXBlIHx8IHAuaGFzTWFnaWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNoYXNNYWdpYyA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGU6IHdpbGwgYmUgdW5kZWZpbmVkIHVudGlsIHdlIGdlbmVyYXRlIHRoZSByZWdleHAgc3JjIGFuZCBmaW5kIG91dFxuICAgICAgICByZXR1cm4gdGhpcy4jaGFzTWFnaWM7XG4gICAgfVxuICAgIC8vIHJlY29uc3RydWN0cyB0aGUgcGF0dGVyblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy4jdG9TdHJpbmcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN0b1N0cmluZztcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jdG9TdHJpbmcgPSB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jdG9TdHJpbmcgPVxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSArICcoJyArIHRoaXMuI3BhcnRzLm1hcChwID0+IFN0cmluZyhwKSkuam9pbignfCcpICsgJyknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjZmlsbE5lZ3MoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2hvdWxkIG9ubHkgY2FsbCBvbiByb290Jyk7XG4gICAgICAgIGlmICh0aGlzLiNmaWxsZWROZWdzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIC8vIGNhbGwgdG9TdHJpbmcoKSBvbmNlIHRvIGZpbGwgdGhpcyBvdXRcbiAgICAgICAgdGhpcy50b1N0cmluZygpO1xuICAgICAgICB0aGlzLiNmaWxsZWROZWdzID0gdHJ1ZTtcbiAgICAgICAgbGV0IG47XG4gICAgICAgIHdoaWxlICgobiA9IHRoaXMuI25lZ3MucG9wKCkpKSB7XG4gICAgICAgICAgICBpZiAobi50eXBlICE9PSAnIScpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyB3YWxrIHVwIHRoZSB0cmVlLCBhcHBlbmRpbmcgZXZlcnRoaW5nIHRoYXQgY29tZXMgQUZURVIgcGFyZW50SW5kZXhcbiAgICAgICAgICAgIGxldCBwID0gbjtcbiAgICAgICAgICAgIGxldCBwcCA9IHAuI3BhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwcCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwLiNwYXJlbnRJbmRleCArIDE7ICFwcC50eXBlICYmIGkgPCBwcC4jcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG4uI3BhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBwYXJ0IGluIGV4dGdsb2IgQVNUPz8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmNvcHlJbihwcC4jcGFydHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBwcDtcbiAgICAgICAgICAgICAgICBwcCA9IHAuI3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVzaCguLi5wYXJ0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwID09PSAnJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJyAmJiAhKHAgaW5zdGFuY2VvZiBBU1QgJiYgcC4jcGFyZW50ID09PSB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXJ0OiAnICsgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jcGFydHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMudHlwZSA9PT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLiNwYXJ0cy5zbGljZSgpLm1hcChwID0+ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyBwIDogcC50b0pTT04oKSkpXG4gICAgICAgICAgICA6IFt0aGlzLnR5cGUsIC4uLnRoaXMuI3BhcnRzLm1hcChwID0+IHAudG9KU09OKCkpXTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpICYmICF0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXQudW5zaGlmdChbXSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW5kKCkgJiZcbiAgICAgICAgICAgICh0aGlzID09PSB0aGlzLiNyb290IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MgJiYgdGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goe30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIGlmICh0aGlzLnR5cGUpIHJldHVybiAhIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpXG4gICAgICAgIGlmICghdGhpcy4jcGFyZW50Py5pc1N0YXJ0KCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLiNwYXJlbnRJbmRleCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIEFIRUFEIG9mIHRoaXMgaXMgYSBuZWdhdGlvbiwgdGhlbiBpdCdzIHN0aWxsIHRoZSBcInN0YXJ0XCJcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuI3BhcmVudDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNwYXJlbnRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHAuI3BhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKCEocHAgaW5zdGFuY2VvZiBBU1QgJiYgcHAudHlwZSA9PT0gJyEnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNFbmQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50Py5pc0VuZCgpO1xuICAgICAgICAvLyBpZiBub3Qgcm9vdCwgaXQnbGwgYWx3YXlzIGhhdmUgYSBwYXJlbnRcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50SW5kZXggPT09IHBsIC0gMTtcbiAgICB9XG4gICAgY29weUluKHBhcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wdXNoKHBhcnQuY2xvbmUodGhpcykpO1xuICAgIH1cbiAgICBjbG9uZShwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgYyA9IG5ldyBBU1QodGhpcy50eXBlLCBwYXJlbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy4jcGFydHMpIHtcbiAgICAgICAgICAgIGMuY29weUluKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBzdGF0aWMgI3BhcnNlQVNUKHN0ciwgYXN0LCBwb3MsIG9wdCkge1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IGJyYWNlU3RhcnQgPSAtMTtcbiAgICAgICAgbGV0IGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgIGlmIChhc3QudHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBvZiBhIGV4dGdsb2IsIGFwcGVuZCB1bnRpbCB3ZSBmaW5kIGEgc3RhcnRcbiAgICAgICAgICAgIGxldCBpID0gcG9zO1xuICAgICAgICAgICAgbGV0IGFjYyA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAvLyBzdGlsbCBhY2N1bXVsYXRlIGVzY2FwZXMgYXQgdGhpcyBwb2ludCwgYnV0IHdlIGRvIGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwaW5nIHx8IGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9ICFlc2NhcGluZztcbiAgICAgICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYnJhY2VTdGFydCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgfHwgYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5CcmFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmFjZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5ub2V4dCAmJiBpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICBhc3QucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gbmV3IEFTVChjLCBhc3QpO1xuICAgICAgICAgICAgICAgICAgICBpID0gQVNULiNwYXJzZUFTVChzdHIsIGV4dCwgaSwgb3B0KTtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNvbWUga2luZCBvZiBleHRnbG9iLCBwb3MgaXMgYXQgdGhlIChcbiAgICAgICAgLy8gZmluZCB0aGUgbmV4dCB8IG9yIClcbiAgICAgICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgICAgICBsZXQgcGFydCA9IG5ldyBBU1QobnVsbCwgYXN0KTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgbGV0IGFjYyA9ICcnO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAvLyBzdGlsbCBhY2N1bXVsYXRlIGVzY2FwZXMgYXQgdGhpcyBwb2ludCwgYnV0IHdlIGRvIGlnbm9yZVxuICAgICAgICAgICAgLy8gc3RhcnRzIHRoYXQgYXJlIGVzY2FwZWRcbiAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9ICFlc2NhcGluZztcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbkJyYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnXicgfHwgYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmFjZU5lZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ10nICYmICEoaSA9PT0gYnJhY2VTdGFydCArIDIgJiYgYnJhY2VOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmFjZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXh0Z2xvYlR5cGUoYykgJiYgc3RyLmNoYXJBdChpKSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gbmV3IEFTVChjLCBwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goZXh0KTtcbiAgICAgICAgICAgICAgICBpID0gQVNULiNwYXJzZUFTVChzdHIsIGV4dCwgaSwgb3B0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjYyA9PT0gJycgJiYgYXN0LiNwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LiNlbXB0eUV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGFzdC5wdXNoKC4uLnBhcnRzLCBwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuZmluaXNoZWQgZXh0Z2xvYlxuICAgICAgICAvLyBpZiB3ZSBnb3QgaGVyZSwgaXQgd2FzIGEgbWFsZm9ybWVkIGV4dGdsb2IhIG5vdCBhbiBleHRnbG9iLCBidXRcbiAgICAgICAgLy8gbWF5YmUgc29tZXRoaW5nIGVsc2UgaW4gdGhlcmUuXG4gICAgICAgIGFzdC50eXBlID0gbnVsbDtcbiAgICAgICAgYXN0LiNoYXNNYWdpYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXN0LiNwYXJ0cyA9IFtzdHIuc3Vic3RyaW5nKHBvcyAtIDEpXTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tR2xvYihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYXN0ID0gbmV3IEFTVChudWxsLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgICBBU1QuI3BhcnNlQVNUKHBhdHRlcm4sIGFzdCwgMCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpZiB0aGVyZSdzIG1hZ2ljLCBvciB0aGUgdW5lc2NhcGVkXG4gICAgLy8gc3RyaW5nIGlmIG5vdC5cbiAgICB0b01NUGF0dGVybigpIHtcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIHJvb3RcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLiNyb290KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jvb3QudG9NTVBhdHRlcm4oKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgY29uc3QgZ2xvYiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgW3JlLCBib2R5LCBoYXNNYWdpYywgdWZsYWddID0gdGhpcy50b1JlZ0V4cFNvdXJjZSgpO1xuICAgICAgICAvLyBpZiB3ZSdyZSBpbiBub2Nhc2UgbW9kZSwgYW5kIG5vdCBub2Nhc2VNYWdpY09ubHksIHRoZW4gd2UgZG9cbiAgICAgICAgLy8gc3RpbGwgbmVlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpZiB3ZSBoYXZlIHRvIGNhc2UtaW5zZW5zaXRpdmVseVxuICAgICAgICAvLyBtYXRjaCBjYXBpdGFsL2xvd2VyY2FzZSBjaGFyYWN0ZXJzLlxuICAgICAgICBjb25zdCBhbnlNYWdpYyA9IGhhc01hZ2ljIHx8XG4gICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyB8fFxuICAgICAgICAgICAgKHRoaXMuI29wdGlvbnMubm9jYXNlICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI29wdGlvbnMubm9jYXNlTWFnaWNPbmx5ICYmXG4gICAgICAgICAgICAgICAgZ2xvYi50b1VwcGVyQ2FzZSgpICE9PSBnbG9iLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIWFueU1hZ2ljKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9ICh0aGlzLiNvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnKSArICh1ZmxhZyA/ICd1JyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFJlZ0V4cChgXiR7cmV9JGAsIGZsYWdzKSwge1xuICAgICAgICAgICAgX3NyYzogcmUsXG4gICAgICAgICAgICBfZ2xvYjogZ2xvYixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9ucztcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgc3RyaW5nIG1hdGNoLCB0aGUgcmVnZXhwIHNvdXJjZSwgd2hldGhlciB0aGVyZSdzIG1hZ2ljXG4gICAgLy8gaW4gdGhlIHJlZ2V4cCAoc28gYSByZWd1bGFyIGV4cHJlc3Npb24gaXMgcmVxdWlyZWQpIGFuZCB3aGV0aGVyIG9yXG4gICAgLy8gbm90IHRoZSB1ZmxhZyBpcyBuZWVkZWQgZm9yIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gKGZvciBwb3NpeCBjbGFzc2VzKVxuICAgIC8vIFRPRE86IGluc3RlYWQgb2YgaW5qZWN0aW5nIHRoZSBzdGFydC9lbmQgYXQgdGhpcyBwb2ludCwganVzdCByZXR1cm5cbiAgICAvLyB0aGUgQk9EWSBvZiB0aGUgcmVnZXhwLCBhbG9uZyB3aXRoIHRoZSBzdGFydC9lbmQgcG9ydGlvbnMgc3VpdGFibGVcbiAgICAvLyBmb3IgYmluZGluZyB0aGUgc3RhcnQvZW5kIGluIGVpdGhlciBhIGpvaW5lZCBmdWxsLXBhdGggbWFrZVJlIGNvbnRleHRcbiAgICAvLyAod2hlcmUgd2UgYmluZCB0byAoXnwvKSwgb3IgYSBzdGFuZGFsb25lIG1hdGNoUGFydCBjb250ZXh0ICh3aGVyZVxuICAgIC8vIHdlIGJpbmQgdG8gXiwgYW5kIG5vdCAvKS4gIE90aGVyd2lzZSBzbGFzaGVzIGdldCBkdXBlZCFcbiAgICAvL1xuICAgIC8vIEluIHBhcnQtbWF0Y2hpbmcgbW9kZSwgdGhlIHN0YXJ0IGlzOlxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQ6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiBeKD8hXFwuXFwuPyQpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiBeXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogXig/IVxcLilcbiAgICAvLyBlbmQgaXM6XG4gICAgLy8gLSBpZiBub3QgaXNFbmQoKTogbm90aGluZ1xuICAgIC8vIC0gZWxzZTogJFxuICAgIC8vXG4gICAgLy8gSW4gZnVsbC1wYXRoIG1hdGNoaW5nIG1vZGUsIHdlIHB1dCB0aGUgc2xhc2ggYXQgdGhlIFNUQVJUIG9mIHRoZVxuICAgIC8vIHBhdHRlcm4sIHNvIHN0YXJ0IGlzOlxuICAgIC8vIC0gaWYgZmlyc3QgcGF0dGVybjogc2FtZSBhcyBwYXJ0LW1hdGNoaW5nIG1vZGVcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0KCk6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiAvKD8hXFwuXFwuPyg/OiR8LykpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiAvXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogLyg/IVxcLilcbiAgICAvLyBlbmQgaXM6XG4gICAgLy8gLSBpZiBsYXN0IHBhdHRlcm4sIHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBlbHNlIG5vdGhpbmdcbiAgICAvL1xuICAgIC8vIEFsd2F5cyBwdXQgdGhlICg/OiR8Lykgb24gbmVnYXRlZCB0YWlscywgdGhvdWdoLCBiZWNhdXNlIHRoYXQgaGFzIHRvIGJlXG4gICAgLy8gdGhlcmUgdG8gYmluZCB0aGUgZW5kIG9mIHRoZSBuZWdhdGVkIHBhdHRlcm4gcG9ydGlvbiwgYW5kIGl0J3MgZWFzaWVyIHRvXG4gICAgLy8ganVzdCBzdGljayBpdCBpbiBub3cgcmF0aGVyIHRoYW4gdHJ5IHRvIGluamVjdCBpdCBsYXRlciBpbiB0aGUgbWlkZGxlIG9mXG4gICAgLy8gdGhlIHBhdHRlcm4uXG4gICAgLy9cbiAgICAvLyBXZSBjYW4ganVzdCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGVuZCwgYW5kIGxlYXZlIGl0IHVwIHRvIHRoZSBjYWxsZXJcbiAgICAvLyB0byBrbm93IHdoZXRoZXIgaXQncyBnb2luZyB0byBiZSB1c2VkIGpvaW5lZCBvciBpbiBwYXJ0cy5cbiAgICAvLyBBbmQsIGlmIHRoZSBzdGFydCBpcyBhZGp1c3RlZCBzbGlnaHRseSwgY2FuIGRvIHRoZSBzYW1lIHRoZXJlOlxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQ6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiAoPzovfF4pKD8hXFwuXFwuPyQpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiAoPzovfF4pXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLilcbiAgICAvL1xuICAgIC8vIEJ1dCBpdCdzIGJldHRlciB0byBoYXZlIGEgc2ltcGxlciBiaW5kaW5nIHdpdGhvdXQgYSBjb25kaXRpb25hbCwgZm9yXG4gICAgLy8gcGVyZm9ybWFuY2UsIHNvIHByb2JhYmx5IGJldHRlciB0byByZXR1cm4gYm90aCBzdGFydCBvcHRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlbiB0aGUgY2FsbGVyIGp1c3QgaWdub3JlcyB0aGUgZW5kIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCBwYXR0ZXJuLFxuICAgIC8vIGFuZCB0aGUgc3RhcnQgYWx3YXlzIGdldHMgYXBwbGllZC5cbiAgICAvL1xuICAgIC8vIEJ1dCB0aGF0J3MgYWx3YXlzIGdvaW5nIHRvIGJlICQgaWYgaXQncyB0aGUgZW5kaW5nIHBhdHRlcm4sIG9yIG5vdGhpbmcsXG4gICAgLy8gc28gdGhlIGNhbGxlciBjYW4ganVzdCBhdHRhY2ggJCBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHdoZW4gYnVpbGRpbmcuXG4gICAgLy9cbiAgICAvLyBTbyB0aGUgdG9kbyBpczpcbiAgICAvLyAtIGJldHRlciBkZXRlY3Qgd2hhdCBraW5kIG9mIHN0YXJ0IGlzIG5lZWRlZFxuICAgIC8vIC0gcmV0dXJuIGJvdGggZmxhdm9ycyBvZiBzdGFydGluZyBwYXR0ZXJuXG4gICAgLy8gLSBhdHRhY2ggJCBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHdoZW4gY3JlYXRpbmcgdGhlIGFjdHVhbCBSZWdFeHBcbiAgICAvL1xuICAgIC8vIEFoLCBidXQgd2FpdCwgbm8sIHRoYXQgYWxsIG9ubHkgYXBwbGllcyB0byB0aGUgcm9vdCB3aGVuIHRoZSBmaXJzdCBwYXR0ZXJuXG4gICAgLy8gaXMgbm90IGFuIGV4dGdsb2IuIElmIHRoZSBmaXJzdCBwYXR0ZXJuIElTIGFuIGV4dGdsb2IsIHRoZW4gd2UgbmVlZCBhbGxcbiAgICAvLyB0aGF0IGRvdCBwcmV2ZW50aW9uIGJpeiB0byBsaXZlIGluIHRoZSBleHRnbG9iIHBvcnRpb25zLCBiZWNhdXNlIGVnXG4gICAgLy8gKygqfC54KikgY2FuIG1hdGNoIC54eSBidXQgbm90IC55eC5cbiAgICAvL1xuICAgIC8vIFNvLCByZXR1cm4gdGhlIHR3byBmbGF2b3JzIGlmIGl0J3MgI3Jvb3QgYW5kIHRoZSBmaXJzdCBjaGlsZCBpcyBub3QgYW5cbiAgICAvLyBBU1QsIG90aGVyd2lzZSBsZWF2ZSBpdCB0byB0aGUgY2hpbGQgQVNUIHRvIGhhbmRsZSBpdCwgYW5kIHRoZXJlLFxuICAgIC8vIHVzZSB0aGUgKD86XnwvKSBzdHlsZSBvZiBzdGFydCBiaW5kaW5nLlxuICAgIC8vXG4gICAgLy8gRXZlbiBzaW1wbGlmaWVkIGZ1cnRoZXI6XG4gICAgLy8gLSBTaW5jZSB0aGUgc3RhcnQgZm9yIGEgam9pbiBpcyBlZyAvKD8hXFwuKSBhbmQgdGhlIHN0YXJ0IGZvciBhIHBhcnRcbiAgICAvLyBpcyBeKD8hXFwuKSwgd2UgY2FuIGp1c3QgcHJlcGVuZCAoPyFcXC4pIHRvIHRoZSBwYXR0ZXJuIChlaXRoZXIgcm9vdFxuICAgIC8vIG9yIHN0YXJ0IG9yIHdoYXRldmVyKSBhbmQgcHJlcGVuZCBeIG9yIC8gYXQgdGhlIFJlZ2V4cCBjb25zdHJ1Y3Rpb24uXG4gICAgdG9SZWdFeHBTb3VyY2UoYWxsb3dEb3QpIHtcbiAgICAgICAgY29uc3QgZG90ID0gYWxsb3dEb3QgPz8gISF0aGlzLiNvcHRpb25zLmRvdDtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICB0aGlzLiNmaWxsTmVncygpO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9FbXB0eSA9IHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAgICAgLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmUsIF8sIGhhc01hZ2ljLCB1ZmxhZ10gPSB0eXBlb2YgcCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBBU1QuI3BhcnNlR2xvYihwLCB0aGlzLiNoYXNNYWdpYywgbm9FbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgOiBwLnRvUmVnRXhwU291cmNlKGFsbG93RG90KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHRoaXMuI2hhc01hZ2ljIHx8IGhhc01hZ2ljO1xuICAgICAgICAgICAgICAgIHRoaXMuI3VmbGFnID0gdGhpcy4jdWZsYWcgfHwgdWZsYWc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcGFydHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHN0cmluZyB0aGF0IHdpbGwgbWF0Y2ggdGhlIHN0YXJ0IG9mIHRoZSBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHByb3RlY3QgYWdhaW5zdCBkb3RzIGFuZCBzdWNoLlxuICAgICAgICAgICAgICAgICAgICAvLyAnLicgYW5kICcuLicgY2Fubm90IG1hdGNoIHVubGVzcyB0aGUgcGF0dGVybiBpcyB0aGF0IGV4YWN0bHksXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQgc3RhcnRzIHdpdGggLiBvciBkb3Q6dHJ1ZSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdFRyYXZBbGxvd2VkID0gdGhpcy4jcGFydHMubGVuZ3RoID09PSAxICYmIGp1c3REb3RzLmhhcyh0aGlzLiNwYXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG90VHJhdkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcyA9IGFkZFBhdHRlcm5TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYSBwb3NzaWJpbGl0eSBvZiBtYXRjaGluZyAuIG9yIC4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByZXZlbnQgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWROb1RyYXYgPSBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvdHMgYXJlIGFsbG93ZWQsIGFuZCB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgIChkb3QgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDApKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC4nKSAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMikpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFxcLlxcLiwgYW5kIHRoZW4gWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNyYy5zdGFydHNXaXRoKCdcXFxcLlxcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHByZXZlbnQgZG90cyBpZiBpdCBjYW4ndCBtYXRjaCBhIGRvdCwgb3IgaWYgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViLXBhdHRlcm4gd2lsbCBiZSBwcmV2ZW50aW5nIGl0IGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWROb0RvdCA9ICFkb3QgJiYgIWFsbG93RG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5lZWROb1RyYXYgPyBzdGFydE5vVHJhdmVyc2FsIDogbmVlZE5vRG90ID8gc3RhcnROb0RvdCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSBcImVuZCBvZiBwYXRoIHBvcnRpb25cIiBwYXR0ZXJuIHRvIG5lZ2F0aW9uIHRhaWxzXG4gICAgICAgICAgICBsZXQgZW5kID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jcm9vdC4jZmlsbGVkTmVncyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gJyg/OiR8XFxcXC8pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsID0gc3RhcnQgKyBzcmMgKyBlbmQ7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGZpbmFsLFxuICAgICAgICAgICAgICAgIHVuZXNjYXBlKHNyYyksXG4gICAgICAgICAgICAgICAgKHRoaXMuI2hhc01hZ2ljID0gISF0aGlzLiNoYXNNYWdpYyksXG4gICAgICAgICAgICAgICAgdGhpcy4jdWZsYWcsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBib2R5ICp0d2ljZSogaWYgaXQncyBhIHJlcGVhdCBwYXR0ZXJuXG4gICAgICAgIC8vIGF0IHRoZSBzdGFydCwgb25jZSBpbiBub2RvdCBtb2RlLCB0aGVuIGFnYWluIGluIGRvdCBtb2RlLCBzbyBhXG4gICAgICAgIC8vIHBhdHRlcm4gbGlrZSAqKD8pIGNhbiBtYXRjaCAneC55J1xuICAgICAgICBjb25zdCByZXBlYXRlZCA9IHRoaXMudHlwZSA9PT0gJyonIHx8IHRoaXMudHlwZSA9PT0gJysnO1xuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYlxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMudHlwZSA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86JztcbiAgICAgICAgbGV0IGJvZHkgPSB0aGlzLiNwYXJ0c1RvUmVnRXhwKGRvdCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCkgJiYgIWJvZHkgJiYgdGhpcy50eXBlICE9PSAnIScpIHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgZXh0Z2xvYiwgaGFzIHRvIGF0IGxlYXN0IGJlICpzb21ldGhpbmcqIHByZXNlbnQsIGlmIGl0J3NcbiAgICAgICAgICAgIC8vIHRoZSBlbnRpcmUgcGF0aCBwb3J0aW9uLlxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuI3BhcnRzID0gW3NdO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIFtzLCB1bmVzY2FwZSh0aGlzLnRvU3RyaW5nKCkpLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBhYnN0cmFjdCBvdXQgdGhpcyBtYXAgbWV0aG9kXG4gICAgICAgIGxldCBib2R5RG90QWxsb3dlZCA9ICFyZXBlYXRlZCB8fCBhbGxvd0RvdCB8fCBkb3QgfHwgIXN0YXJ0Tm9Eb3RcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogdGhpcy4jcGFydHNUb1JlZ0V4cCh0cnVlKTtcbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkID09PSBib2R5KSB7XG4gICAgICAgICAgICBib2R5RG90QWxsb3dlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCkge1xuICAgICAgICAgICAgYm9keSA9IGAoPzoke2JvZHl9KSg/OiR7Ym9keURvdEFsbG93ZWR9KSo/YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBlbXB0eSAhKCkgaXMgZXhhY3RseSBlcXVpdmFsZW50IHRvIGEgc3Rhck5vRW1wdHlcbiAgICAgICAgbGV0IGZpbmFsID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICchJyAmJiB0aGlzLiNlbXB0eUV4dCkge1xuICAgICAgICAgICAgZmluYWwgPSAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgKyBzdGFyTm9FbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gdGhpcy50eXBlID09PSAnISdcbiAgICAgICAgICAgICAgICA/IC8vICEoKSBtdXN0IG1hdGNoIHNvbWV0aGluZyxidXQgISh4KSBjYW4gbWF0Y2ggJydcbiAgICAgICAgICAgICAgICAgICAgJykpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCAmJiAhYWxsb3dEb3QgPyBzdGFydE5vRG90IDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJz8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcpPydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKycgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKicgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKT9gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYCkke3RoaXMudHlwZX1gO1xuICAgICAgICAgICAgZmluYWwgPSBzdGFydCArIGJvZHkgKyBjbG9zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICB1bmVzY2FwZShib2R5KSxcbiAgICAgICAgICAgICh0aGlzLiNoYXNNYWdpYyA9ICEhdGhpcy4jaGFzTWFnaWMpLFxuICAgICAgICAgICAgdGhpcy4jdWZsYWcsXG4gICAgICAgIF07XG4gICAgfVxuICAgICNwYXJ0c1RvUmVnRXhwKGRvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFydHNcbiAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAvLyBleHRnbG9iIEFTVHMgc2hvdWxkIG9ubHkgY29udGFpbiBwYXJlbnQgQVNUc1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgdHlwZSBpbiBleHRnbG9iIGFzdD8/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgLy8gY2FuIGlnbm9yZSBoYXNNYWdpYywgYmVjYXVzZSBleHRnbG9icyBhcmUgYWxyZWFkeSBhbHdheXMgbWFnaWNcbiAgICAgICAgICAgIGNvbnN0IFtyZSwgXywgX2hhc01hZ2ljLCB1ZmxhZ10gPSBwLnRvUmVnRXhwU291cmNlKGRvdCk7XG4gICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihwID0+ICEodGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpKSB8fCAhIXApXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgIH1cbiAgICBzdGF0aWMgI3BhcnNlR2xvYihnbG9iLCBoYXNNYWdpYywgbm9FbXB0eSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmUgPSAnJztcbiAgICAgICAgbGV0IHVmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZSArPSAocmVTcGVjaWFscy5oYXMoYykgPyAnXFxcXCcgOiAnJykgKyBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBnbG9iLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gJ1xcXFxcXFxcJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NyYywgbmVlZFVmbGFnLCBjb25zdW1lZCwgbWFnaWNdID0gcGFyc2VDbGFzcyhnbG9iLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3JjO1xuICAgICAgICAgICAgICAgICAgICB1ZmxhZyA9IHVmbGFnIHx8IG5lZWRVZmxhZztcbiAgICAgICAgICAgICAgICAgICAgaSArPSBjb25zdW1lZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgbWFnaWM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9FbXB0eSAmJiBnbG9iID09PSAnKicpXG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHN0YXJOb0VtcHR5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3RhcjtcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgcmUgKz0gcW1hcms7XG4gICAgICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmUgKz0gcmVnRXhwRXNjYXBlKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmUsIHVuZXNjYXBlKGdsb2IpLCAhIWhhc01hZ2ljLCB1ZmxhZ107XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/ast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/brace-expressions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/esm/brace-expressions.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseClass: () => (/* binding */ parseClass)\n/* harmony export */ });\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2JyYWNlLWV4cHJlc3Npb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLEVBQUUsSUFBSSxHQUFHLElBQUksR0FBRztBQUN2Qyx1QkFBdUIsRUFBRSxJQUFJLEdBQUc7QUFDaEM7QUFDQSx1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsRUFBRSxJQUFJLEVBQUU7QUFDL0IsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEVBQUU7QUFDekIsdUJBQXVCLEVBQUU7QUFDekIsdUJBQXVCLEVBQUU7QUFDekIsdUJBQXVCLEdBQUc7QUFDMUIsc0JBQXNCLEVBQUUsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWFrZXBpbjJyL0RvY3VtZW50cy9wcm9qZWN0cy9tYWtlcGluMnIuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9lc20vYnJhY2UtZXhwcmVzc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNsYXRlIHRoZSB2YXJpb3VzIHBvc2l4IGNoYXJhY3RlciBjbGFzc2VzIGludG8gdW5pY29kZSBwcm9wZXJ0aWVzXG4vLyB0aGlzIHdvcmtzIGFjcm9zcyBhbGwgdW5pY29kZSBsb2NhbGVzXG4vLyB7IDxwb3NpeCBjbGFzcz46IFs8dHJhbnNsYXRpb24+LCAvdSBmbGFnIHJlcXVpcmVkLCBuZWdhdGVkXVxuY29uc3QgcG9zaXhDbGFzc2VzID0ge1xuICAgICdbOmFsbnVtOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6YWxwaGE6XSc6IFsnXFxcXHB7TH1cXFxccHtObH0nLCB0cnVlXSxcbiAgICAnWzphc2NpaTpdJzogWydcXFxceCcgKyAnMDAtXFxcXHgnICsgJzdmJywgZmFsc2VdLFxuICAgICdbOmJsYW5rOl0nOiBbJ1xcXFxwe1pzfVxcXFx0JywgdHJ1ZV0sXG4gICAgJ1s6Y250cmw6XSc6IFsnXFxcXHB7Q2N9JywgdHJ1ZV0sXG4gICAgJ1s6ZGlnaXQ6XSc6IFsnXFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6Z3JhcGg6XSc6IFsnXFxcXHB7Wn1cXFxccHtDfScsIHRydWUsIHRydWVdLFxuICAgICdbOmxvd2VyOl0nOiBbJ1xcXFxwe0xsfScsIHRydWVdLFxuICAgICdbOnByaW50Ol0nOiBbJ1xcXFxwe0N9JywgdHJ1ZV0sXG4gICAgJ1s6cHVuY3Q6XSc6IFsnXFxcXHB7UH0nLCB0cnVlXSxcbiAgICAnWzpzcGFjZTpdJzogWydcXFxccHtafVxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLCB0cnVlXSxcbiAgICAnWzp1cHBlcjpdJzogWydcXFxccHtMdX0nLCB0cnVlXSxcbiAgICAnWzp3b3JkOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9XFxcXHB7UGN9JywgdHJ1ZV0sXG4gICAgJ1s6eGRpZ2l0Ol0nOiBbJ0EtRmEtZjAtOScsIGZhbHNlXSxcbn07XG4vLyBvbmx5IG5lZWQgdG8gZXNjYXBlIGEgZmV3IHRoaW5ncyBpbnNpZGUgb2YgYnJhY2UgZXhwcmVzc2lvbnNcbi8vIGVzY2FwZXM6IFsgXFwgXSAtXG5jb25zdCBicmFjZUVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXC1dL2csICdcXFxcJCYnKTtcbi8vIGVzY2FwZSBhbGwgcmVnZXhwIG1hZ2ljIGNoYXJhY3RlcnNcbmNvbnN0IHJlZ2V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBldmVyeXRoaW5nIGhhcyBhbHJlYWR5IGJlZW4gZXNjYXBlZCwgd2UganVzdCBoYXZlIHRvIGpvaW5cbmNvbnN0IHJhbmdlc1RvU3RyaW5nID0gKHJhbmdlcykgPT4gcmFuZ2VzLmpvaW4oJycpO1xuLy8gdGFrZXMgYSBnbG9iIHN0cmluZyBhdCBhIHBvc2l4IGJyYWNlIGV4cHJlc3Npb24sIGFuZCByZXR1cm5zXG4vLyBhbiBlcXVpdmFsZW50IHJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2UsIGFuZCBib29sZWFuIGluZGljYXRpbmdcbi8vIHdoZXRoZXIgdGhlIC91IGZsYWcgbmVlZHMgdG8gYmUgYXBwbGllZCwgYW5kIHRoZSBudW1iZXIgb2YgY2hhcnNcbi8vIGNvbnN1bWVkIHRvIHBhcnNlIHRoZSBjaGFyYWN0ZXIgY2xhc3MuXG4vLyBUaGlzIGFsc28gcmVtb3ZlcyBvdXQgb2Ygb3JkZXIgcmFuZ2VzLCBhbmQgcmV0dXJucyAoJC4pIGlmIHRoZVxuLy8gZW50aXJlIGNsYXNzIGp1c3Qgbm8gZ29vZC5cbmV4cG9ydCBjb25zdCBwYXJzZUNsYXNzID0gKGdsb2IsIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb247XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGdsb2IuY2hhckF0KHBvcykgIT09ICdbJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbiBhIGJyYWNlIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBuZWdzID0gW107XG4gICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgIGxldCBzYXdTdGFydCA9IGZhbHNlO1xuICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICBsZXQgZW5kUG9zID0gcG9zO1xuICAgIGxldCByYW5nZVN0YXJ0ID0gJyc7XG4gICAgV0hJTEU6IHdoaWxlIChpIDwgZ2xvYi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICBpZiAoKGMgPT09ICchJyB8fCBjID09PSAnXicpICYmIGkgPT09IHBvcyArIDEpIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ10nICYmIHNhd1N0YXJ0ICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgZW5kUG9zID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzYXdTdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGlmICghZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNjYXBlZCBcXCBjaGFyLCBmYWxsIHRocm91Z2ggYW5kIHRyZWF0IGxpa2Ugbm9ybWFsIGNoYXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1snICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGEgcG9zaXggY2xhc3MsIGEgY29sbGF0aW9uIGVxdWl2YWxlbnQsIG9yIGp1c3QgYSBbXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjbHMsIFt1bmlwLCB1LCBuZWddXSBvZiBPYmplY3QuZW50cmllcyhwb3NpeENsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aChjbHMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQsIFthLVtdIGlzIGZpbmUsIGJ1dCBub3QgW2EtWzphbHBoYV1dXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSArPSBjbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVncy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCB1O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBXSElMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGl0J3MganVzdCBhIG5vcm1hbCBjaGFyYWN0ZXIsIGVmZmVjdGl2ZWx5XG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAvLyB0aHJvdyB0aGlzIHJhbmdlIGF3YXkgaWYgaXQncyBub3QgdmFsaWQsIGJ1dCBvdGhlcnNcbiAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBtYXRjaC5cbiAgICAgICAgICAgIGlmIChjID4gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKHJhbmdlU3RhcnQpICsgJy0nICsgYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSAnJztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBtaWdodCBiZSB0aGUgc3RhcnQgb2YgYSByYW5nZS5cbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBjLWQgb3IgYy1dIG9yIGM8bW9yZS4uLj5dIG9yIGNdIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLV0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMgKyAnLScpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBjO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHRoZSBzdGFydCBvZiBhIHJhbmdlLCBqdXN0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGVuZFBvcyA8IGkpIHtcbiAgICAgICAgLy8gZGlkbid0IHNlZSB0aGUgZW5kIG9mIHRoZSBjbGFzcywgbm90IGEgdmFsaWQgY2xhc3MsXG4gICAgICAgIC8vIGJ1dCBtaWdodCBzdGlsbCBiZSB2YWxpZCBhcyBhIGxpdGVyYWwgbWF0Y2guXG4gICAgICAgIHJldHVybiBbJycsIGZhbHNlLCAwLCBmYWxzZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBubyByYW5nZXMgYW5kIG5vIG5lZ2F0ZXMsIHRoZW4gd2UgaGF2ZSBhIHJhbmdlIHRoYXRcbiAgICAvLyBjYW5ub3QgcG9zc2libHkgbWF0Y2ggYW55dGhpbmcsIGFuZCB0aGF0IHBvaXNvbnMgdGhlIHdob2xlIGdsb2JcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgIW5lZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG9uZSBwb3NpdGl2ZSByYW5nZSwgYW5kIGl0J3MgYSBzaW5nbGUgY2hhcmFjdGVyLCB0aGVuIHRoYXQnc1xuICAgIC8vIG5vdCBhY3R1YWxseSBhIG1hZ2ljIHBhdHRlcm4sIGl0J3MganVzdCB0aGF0IG9uZSBsaXRlcmFsIGNoYXJhY3Rlci5cbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyZWF0IHRoYXQgYXMgXCJtYWdpY1wiLCB3ZSBzaG91bGQganVzdCByZXR1cm4gdGhlIGxpdGVyYWxcbiAgICAvLyBjaGFyYWN0ZXIuIFtfXSBpcyBhIHBlcmZlY3RseSB2YWxpZCB3YXkgdG8gZXNjYXBlIGdsb2IgbWFnaWMgY2hhcnMuXG4gICAgaWYgKG5lZ3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHJhbmdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgL15cXFxcPy4kLy50ZXN0KHJhbmdlc1swXSkgJiZcbiAgICAgICAgIW5lZ2F0ZSkge1xuICAgICAgICBjb25zdCByID0gcmFuZ2VzWzBdLmxlbmd0aCA9PT0gMiA/IHJhbmdlc1swXS5zbGljZSgtMSkgOiByYW5nZXNbMF07XG4gICAgICAgIHJldHVybiBbcmVnZXhwRXNjYXBlKHIpLCBmYWxzZSwgZW5kUG9zIC0gcG9zLCBmYWxzZV07XG4gICAgfVxuICAgIGNvbnN0IHNyYW5nZXMgPSAnWycgKyAobmVnYXRlID8gJ14nIDogJycpICsgcmFuZ2VzVG9TdHJpbmcocmFuZ2VzKSArICddJztcbiAgICBjb25zdCBzbmVncyA9ICdbJyArIChuZWdhdGUgPyAnJyA6ICdeJykgKyByYW5nZXNUb1N0cmluZyhuZWdzKSArICddJztcbiAgICBjb25zdCBjb21iID0gcmFuZ2VzLmxlbmd0aCAmJiBuZWdzLmxlbmd0aFxuICAgICAgICA/ICcoJyArIHNyYW5nZXMgKyAnfCcgKyBzbmVncyArICcpJ1xuICAgICAgICA6IHJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgID8gc3Jhbmdlc1xuICAgICAgICAgICAgOiBzbmVncztcbiAgICByZXR1cm4gW2NvbWIsIHVmbGFnLCBlbmRQb3MgLSBwb3MsIHRydWVdO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyYWNlLWV4cHJlc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/brace-expressions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/escape.js":
/*!*********************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/esm/escape.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escape: () => (/* binding */ escape)\n/* harmony export */ });\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2VzY2FwZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsZ0NBQWdDLElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21ha2VwaW4yci9Eb2N1bWVudHMvcHJvamVjdHMvbWFrZXBpbjJyLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2VzY2FwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVzY2FwZSBhbGwgbWFnaWMgY2hhcmFjdGVycyBpbiBhIGdsb2IgcGF0dGVybi5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlIHwgR2xvYk9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGV9XG4gKiBvcHRpb24gaXMgdXNlZCwgdGhlbiBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIGluIGBbXWAsIGJlY2F1c2VcbiAqIGEgbWFnaWMgY2hhcmFjdGVyIHdyYXBwZWQgaW4gYSBjaGFyYWN0ZXIgY2xhc3MgY2FuIG9ubHkgYmUgc2F0aXNmaWVkIGJ5XG4gKiB0aGF0IGV4YWN0IGNoYXJhY3Rlci4gIEluIHRoaXMgbW9kZSwgYFxcYCBpcyBfbm90XyBlc2NhcGVkLCBiZWNhdXNlIGl0IGlzXG4gKiBub3QgaW50ZXJwcmV0ZWQgYXMgYSBtYWdpYyBjaGFyYWN0ZXIsIGJ1dCBpbnN0ZWFkIGFzIGEgcGF0aCBzZXBhcmF0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGUgPSAocywgeyB3aW5kb3dzUGF0aHNOb0VzY2FwZSA9IGZhbHNlLCB9ID0ge30pID0+IHtcbiAgICAvLyBkb24ndCBuZWVkIHRvIGVzY2FwZSArQCEgYmVjYXVzZSB3ZSBlc2NhcGUgdGhlIHBhcmVuc1xuICAgIC8vIHRoYXQgbWFrZSB0aG9zZSBtYWdpYywgYW5kIGVzY2FwaW5nICEgYXMgWyFdIGlzbid0IHZhbGlkLFxuICAgIC8vIGJlY2F1c2UgWyFdXSBpcyBhIHZhbGlkIGdsb2IgY2xhc3MgbWVhbmluZyBub3QgJ10nLlxuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvWz8qKClbXFxdXS9nLCAnWyQmXScpXG4gICAgICAgIDogcy5yZXBsYWNlKC9bPyooKVtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/escape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* reexport safe */ _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST),\n/* harmony export */   GLOBSTAR: () => (/* binding */ GLOBSTAR),\n/* harmony export */   Minimatch: () => (/* binding */ Minimatch),\n/* harmony export */   braceExpand: () => (/* binding */ braceExpand),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   escape: () => (/* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   makeRe: () => (/* binding */ makeRe),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   minimatch: () => (/* binding */ minimatch),\n/* harmony export */   sep: () => (/* binding */ sep),\n/* harmony export */   unescape: () => (/* reexport safe */ _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape)\n/* harmony export */ });\n/* harmony import */ var brace_expansion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! brace-expansion */ \"(rsc)/./node_modules/brace-expansion/index.js\");\n/* harmony import */ var _assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/assert-valid-pattern.js\");\n/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/ast.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/escape.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/unescape.js\");\n\n\n\n\n\nconst minimatch = (p, pattern, options = {}) => {\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nconst sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nconst GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return brace_expansion__WEBPACK_IMPORTED_MODULE_0__(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\n\n\n\n/* c8 ignore stop */\nminimatch.AST = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape;\nminimatch.unescape = _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQzBCO0FBQ2hDO0FBQ007QUFDSTtBQUNsQywyQ0FBMkM7QUFDbEQsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQztBQUM1QztBQUNBLHNCQUFzQixxQkFBcUI7QUFDcEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDLHNDQUFzQztBQUN0QztBQUNBLHNDQUFzQztBQUN0QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsS0FBSyxHQUFHO0FBQ1IsS0FBSyxLQUFLO0FBQ1YsS0FBSyxJQUFJLElBQUksRUFBRTtBQUNmLEtBQUssSUFBSSxFQUFFLElBQUk7QUFDZjtBQUNBO0FBQ0EsS0FBSyxJQUFJLE9BQU8sSUFBSTtBQUNwQixLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQ1QsMENBQTBDO0FBQ2pELElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUM7QUFDNUM7QUFDTywwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDdkM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFFBQVEsNEVBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRCxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsMkJBQTJCO0FBQ25DLFFBQVEsOEJBQThCO0FBQ3RDO0FBQ0EsUUFBUSxxQ0FBcUM7QUFDN0M7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0Esd0VBQXdFLG9CQUFvQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRFQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBRztBQUN0QjtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytCO0FBQ007QUFDSTtBQUN6QztBQUNBLGdCQUFnQix3Q0FBRztBQUNuQjtBQUNBLG1CQUFtQiw4Q0FBTTtBQUN6QixxQkFBcUIsa0RBQVE7QUFDN0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWtlcGluMnIvRG9jdW1lbnRzL3Byb2plY3RzL21ha2VwaW4yci5naXRodWIuaW8vbm9kZV9tb2R1bGVzL2dsb2Ivbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXhwYW5kIGZyb20gJ2JyYWNlLWV4cGFuc2lvbic7XG5pbXBvcnQgeyBhc3NlcnRWYWxpZFBhdHRlcm4gfSBmcm9tICcuL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzJztcbmltcG9ydCB7IEFTVCB9IGZyb20gJy4vYXN0LmpzJztcbmltcG9ydCB7IGVzY2FwZSB9IGZyb20gJy4vZXNjYXBlLmpzJztcbmltcG9ydCB7IHVuZXNjYXBlIH0gZnJvbSAnLi91bmVzY2FwZS5qcyc7XG5leHBvcnQgY29uc3QgbWluaW1hdGNoID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKTtcbn07XG4vLyBPcHRpbWl6ZWQgY2hlY2tpbmcgZm9yIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm5zLlxuY29uc3Qgc3RhckRvdEV4dFJFID0gL15cXCorKFteK0AhP1xcKlxcW1xcKF0qKSQvO1xuY29uc3Qgc3RhckRvdEV4dFRlc3QgPSAoZXh0KSA9PiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0RG90ID0gKGV4dCkgPT4gKGYpID0+IGYuZW5kc1dpdGgoZXh0KTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90ID0gKGV4dCkgPT4ge1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdFN0YXJSRSA9IC9eXFwqK1xcLlxcKiskLztcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdCA9IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0RG90ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IGRvdFN0YXJSRSA9IC9eXFwuXFwqKyQvO1xuY29uc3QgZG90U3RhclRlc3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyUkUgPSAvXlxcKiskLztcbmNvbnN0IHN0YXJUZXN0ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJUZXN0RG90ID0gKGYpID0+IGYubGVuZ3RoICE9PSAwICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xuY29uc3QgcW1hcmtzUkUgPSAvXlxcPysoW14rQCE/XFwqXFxbXFwoXSopPyQvO1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZSA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlRG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3REb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmICFmLnN0YXJ0c1dpdGgoJy4nKTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHREb3QgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG59O1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/ICh0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHByb2Nlc3MuZW52ICYmXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTUlOSU1BVENIX1RFU1RJTkdfUExBVEZPUk1fXykgfHxcbiAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ3Bvc2l4Jyk7XG5jb25zdCBwYXRoID0ge1xuICAgIHdpbjMyOiB7IHNlcDogJ1xcXFwnIH0sXG4gICAgcG9zaXg6IHsgc2VwOiAnLycgfSxcbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0IGNvbnN0IHNlcCA9IGRlZmF1bHRQbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHBhdGgud2luMzIuc2VwIDogcGF0aC5wb3NpeC5zZXA7XG5taW5pbWF0Y2guc2VwID0gc2VwO1xuZXhwb3J0IGNvbnN0IEdMT0JTVEFSID0gU3ltYm9sKCdnbG9ic3RhciAqKicpO1xubWluaW1hdGNoLkdMT0JTVEFSID0gR0xPQlNUQVI7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFwvKSkuKSo/Jztcbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG5leHBvcnQgY29uc3QgZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gKHApID0+IG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKTtcbm1pbmltYXRjaC5maWx0ZXIgPSBmaWx0ZXI7XG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCBiKTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0cyA9IChkZWYpID0+IHtcbiAgICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1pbmltYXRjaDtcbiAgICB9XG4gICAgY29uc3Qgb3JpZyA9IG1pbmltYXRjaDtcbiAgICBjb25zdCBtID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obSwge1xuICAgICAgICBNaW5pbWF0Y2g6IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBkZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQVNUOiBjbGFzcyBBU1QgZXh0ZW5kcyBvcmlnLkFTVCB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIodHlwZSwgcGFyZW50LCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLnVuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGZpbHRlcjogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBkZWZhdWx0czogKG9wdGlvbnMpID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYWtlUmU6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgYnJhY2VFeHBhbmQ6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYXRjaDogKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIHNlcDogb3JpZy5zZXAsXG4gICAgICAgIEdMT0JTVEFSOiBHTE9CU1RBUixcbiAgICB9KTtcbn07XG5taW5pbWF0Y2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xuZXhwb3J0IGNvbnN0IGJyYWNlRXhwYW5kID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAgIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gICAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pO1xufTtcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kO1xuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5leHBvcnQgY29uc3QgbWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYWtlUmUoKTtcbm1pbmltYXRjaC5tYWtlUmUgPSBtYWtlUmU7XG5leHBvcnQgY29uc3QgbWF0Y2ggPSAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIGxpc3QgPSBsaXN0LmZpbHRlcihmID0+IG1tLm1hdGNoKGYpKTtcbiAgICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxpc3QucHVzaChwYXR0ZXJuKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xubWluaW1hdGNoLm1hdGNoID0gbWF0Y2g7XG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYk1hZ2ljID0gL1s/Kl18WytAIV1cXCguKj9cXCl8XFxbfFxcXS87XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuZXhwb3J0IGNsYXNzIE1pbmltYXRjaCB7XG4gICAgb3B0aW9ucztcbiAgICBzZXQ7XG4gICAgcGF0dGVybjtcbiAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTtcbiAgICBub25lZ2F0ZTtcbiAgICBuZWdhdGU7XG4gICAgY29tbWVudDtcbiAgICBlbXB0eTtcbiAgICBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICBwYXJ0aWFsO1xuICAgIGdsb2JTZXQ7XG4gICAgZ2xvYlBhcnRzO1xuICAgIG5vY2FzZTtcbiAgICBpc1dpbmRvd3M7XG4gICAgcGxhdGZvcm07XG4gICAgd2luZG93c05vTWFnaWNSb290O1xuICAgIHJlZ2V4cDtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdGlvbnMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLmlzV2luZG93cyA9IHRoaXMucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8IG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID09PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyA9ICEhb3B0aW9ucy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICAgICAgdGhpcy5yZWdleHAgPSBudWxsO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vbmVnYXRlID0gISFvcHRpb25zLm5vbmVnYXRlO1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbDtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSAhIXRoaXMub3B0aW9ucy5ub2Nhc2U7XG4gICAgICAgIHRoaXMud2luZG93c05vTWFnaWNSb290ID1cbiAgICAgICAgICAgIG9wdGlvbnMud2luZG93c05vTWFnaWNSb290ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMud2luZG93c05vTWFnaWNSb290XG4gICAgICAgICAgICAgICAgOiAhISh0aGlzLmlzV2luZG93cyAmJiB0aGlzLm5vY2FzZSk7XG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFtdO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNldCA9IFtdO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gICAgICAgIHRoaXMubWFrZSgpO1xuICAgIH1cbiAgICBoYXNNYWdpYygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYWdpY2FsQnJhY2VzICYmIHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnKC4uLl8pIHsgfVxuICAgIG1ha2UoKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgICAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgICAgICAgdGhpcy5wYXJzZU5lZ2F0ZSgpO1xuICAgICAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gWy4uLm5ldyBTZXQodGhpcy5icmFjZUV4cGFuZCgpKV07XG4gICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnID0gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlNldCk7XG4gICAgICAgIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZlxuICAgICAgICAvLyBwYXRoLXBvcnRpb24gbWF0Y2hpbmcgcGF0dGVybnMuXG4gICAgICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAgICAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBwcmVwcm9jZXNzIHRvIG1ha2UgdGhlIGdsb2IgcGF0dGVybiBzZXRzIGEgYml0IHNpbXBsZXJcbiAgICAgICAgLy8gYW5kIGRlZHVwZWQuICBUaGVyZSBhcmUgc29tZSBwZXJmLWtpbGxpbmcgcGF0dGVybnMgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gcHJvYmxlbXMgd2l0aCBhIGdsb2Igd2FsaywgYnV0IHdlIGNhbiBzaW1wbGlmeSB0aGVtIGRvd24gYSBiaXQuXG4gICAgICAgIGNvbnN0IHJhd0dsb2JQYXJ0cyA9IHRoaXMuZ2xvYlNldC5tYXAocyA9PiB0aGlzLnNsYXNoU3BsaXQocykpO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IHRoaXMucHJlcHJvY2VzcyhyYXdHbG9iUGFydHMpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iUGFydHMpO1xuICAgICAgICAvLyBnbG9iIC0tPiByZWdleHBzXG4gICAgICAgIGxldCBzZXQgPSB0aGlzLmdsb2JQYXJ0cy5tYXAoKHMsIF8sIF9fKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIGEgZHJpdmUgb3IgdW5jIHBhdGguXG4gICAgICAgICAgICAgICAgY29uc3QgaXNVTkMgPSBzWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBzWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAoc1syXSA9PT0gJz8nIHx8ICFnbG9iTWFnaWMudGVzdChzWzJdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWdsb2JNYWdpYy50ZXN0KHNbM10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHJpdmUgPSAvXlthLXpdOi9pLnRlc3Qoc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVU5DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucy5zbGljZSgwLCA0KSwgLi4ucy5zbGljZSg0KS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEcml2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NbMF0sIC4uLnMuc2xpY2UoMSkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHMubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5zZXQgPSBzZXQuZmlsdGVyKHMgPT4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTEpO1xuICAgICAgICAvLyBkbyBub3QgdHJlYXQgdGhlID8gaW4gVU5DIHBhdGhzIGFzIG1hZ2ljXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnNldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iUGFydHNbaV1bMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gJz8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5zZXQpO1xuICAgIH1cbiAgICAvLyB2YXJpb3VzIHRyYW5zZm9ybXMgdG8gZXF1aXZhbGVudCBwYXR0ZXJuIHNldHMgdGhhdCBhcmVcbiAgICAvLyBmYXN0ZXIgdG8gcHJvY2VzcyBpbiBhIGZpbGVzeXN0ZW0gd2Fsay4gIFRoZSBnb2FsIGlzIHRvXG4gICAgLy8gZWxpbWluYXRlIHdoYXQgd2UgY2FuLCBhbmQgcHVzaCBhbGwgKiogcGF0dGVybnMgYXMgZmFyXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGFzIHBvc3NpYmxlLCBldmVuIGlmIGl0IGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGF0dGVybnMgdGhhdCB3ZSBoYXZlIHRvIHByb2Nlc3MuXG4gICAgcHJlcHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgbm90IGluIGdsb2JzdGFyIG1vZGUsIHRoZW4gdHVybiBhbGwgKiogaW50byAqXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdsb2JQYXJ0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYlBhcnRzW2ldW2pdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV1bal0gPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIC8vIGFnZ3Jlc3NpdmUgb3B0aW1pemF0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBmcyB3YWxraW5nXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLnNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDEpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgYmFzaWMgb3B0aW1pemF0aW9ucyB0byByZW1vdmUgc29tZSAuLiBwYXJ0c1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5sZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IGNvbGxhcHNlIG11bHRpcGxlICoqIHBvcnRpb25zIGludG8gb25lXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBqdXN0IGdldCByaWQgb2YgYWRqYXNjZW50ICoqIHBvcnRpb25zXG4gICAgYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGdzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tpICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCBpIC0gZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgYWRqYXNjZW50ICoqIGFuZCByZXNvbHZlIC4uIHBvcnRpb25zXG4gICAgbGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0cy5yZWR1Y2UoKHNldCwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnKionICYmIHByZXYgPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJy4uJyAmJiBwcmV2ICE9PSAnLicgJiYgcHJldiAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldmVsVHdvRmlsZU9wdGltaXplKHBhcnRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICAgICAgICAgIHBhcnRzID0gdGhpcy5zbGFzaFNwbGl0KHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgfVxuICAgIC8vIEZpcnN0IHBoYXNlOiBzaW5nbGUtcGF0dGVybiBwcm9jZXNzaW5nXG4gICAgLy8gPHByZT4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHJlc3Q+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxwPiBpcyBhbnkgcG9ydGlvbiBvdGhlciB0aGFuIC4sIC4uLCAnJywgb3IgKipcbiAgICAvLyA8ZT4gaXMgLiBvciAnJ1xuICAgIC8vXG4gICAgLy8gKiovLi4gaXMgKmJydXRhbCogZm9yIGZpbGVzeXN0ZW0gd2Fsa2luZyBwZXJmb3JtYW5jZSwgYmVjYXVzZVxuICAgIC8vIGl0IGVmZmVjdGl2ZWx5IHJlc2V0cyB0aGUgcmVjdXJzaXZlIHdhbGsgZWFjaCB0aW1lIGl0IG9jY3VycyxcbiAgICAvLyBhbmQgKiogY2Fubm90IGJlIHJlZHVjZWQgb3V0IGJ5IGEgLi4gcGF0dGVybiBwYXJ0IGxpa2UgYSByZWdleHBcbiAgICAvLyBvciBtb3N0IHN0cmluZ3MgKG90aGVyIHRoYW4gLi4sIC4sIGFuZCAnJykgY2FuIGJlLlxuICAgIC8vXG4gICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyAqKi8qKi88cmVzdD4gLT4gKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyAqKi8qLzxyZXN0PiAtPiAqLyoqLzxyZXN0PiA8PT0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lc24ndCBmb2xsb3dcbiAgICAvLyB0aGlzIFdPVUxEIGJlIGFsbG93ZWQgaWYgKiogZGlkIGZvbGxvdyBzeW1saW5rcywgb3IgKiBkaWRuJ3RcbiAgICBmaXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnRzIG9mIGdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3NzID0gZ3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tnc3MgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPHByZT4vKiovKiovPHJlc3Q+IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3NzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWcsIGlmIGdzIGlzIDIgYW5kIGdzcyBpcyA0LCB0aGF0IG1lYW5zIHdlIGhhdmUgMyAqKlxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0cywgYW5kIGNhbiByZW1vdmUgMiBvZiB0aGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3NzID4gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncyArIDEsIGdzcyAtIGdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRzW2dzICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tncyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHBhcnRzW2dzICsgM107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlZGl0IHBhcnRzIGluIHBsYWNlLCBhbmQgcHVzaCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHBhcnRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcltnc10gPSAnKionO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHMucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGdzLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkRG90ID0gZGQgPT09IDEgJiYgcGFydHNbZGQgKyAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGluID0gbmVlZERvdCA/IFsnLiddIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyLCAuLi5zcGxpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8gc2Vjb25kIHBoYXNlOiBtdWx0aS1wYXR0ZXJuIGRlZHVwZXNcbiAgICAvLyB7PHByZT4vKi88cmVzdD4sPHByZT4vPHA+LzxyZXN0Pn0gLT4gPHByZT4vKi88cmVzdD5cbiAgICAvLyB7PHByZT4vPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi8qKi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvLyBeLS0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lbnMndCBmb2xsb3cgc3ltbGlua3NcbiAgICBzZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IHRoaXMucGFydHNNYXRjaChnbG9iUGFydHNbaV0sIGdsb2JQYXJ0c1tqXSwgIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbal0gPSBtYXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5maWx0ZXIoZ3MgPT4gZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcGFydHNNYXRjaChhLCBiLCBlbXB0eUdTTWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgYWkgPSAwO1xuICAgICAgICBsZXQgYmkgPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCB3aGljaCA9ICcnO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYVthaV0gPT09IGJbYmldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2hpY2ggPT09ICdiJyA/IGJbYmldIDogYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBhW2FpXSA9PT0gJyoqJyAmJiBiW2JpXSA9PT0gYVthaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYltiaV0gPT09ICcqKicgJiYgYVthaV0gPT09IGJbYmkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYVthaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGJbYmldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWJbYmldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJbYmldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFhW2FpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYVthaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdhJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2InO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZmFsbCBvdXQgb2YgdGhlIGxvb3AsIGl0IG1lYW5zIHRoZXkgdHdvIGFyZSBpZGVudGljYWxcbiAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGVpciBsZW5ndGhzIG1hdGNoXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uZWdhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5lZ2F0ZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJzsgaSsrKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSAhbmVnYXRlO1xuICAgICAgICAgICAgbmVnYXRlT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZ2F0ZU9mZnNldClcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc2xpY2UobmVnYXRlT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gICAgLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuICAgIC8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuICAgIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgICBtYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gVU5DIHBhdGhzIGxpa2UgLy8/L1g6Ly4uLiBjYW4gbWF0Y2ggWDovLi4uIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIC8vIERyaXZlIGxldHRlcnMgaW4gYWJzb2x1dGUgZHJpdmUgb3IgdW5jIHBhdGhzIGFyZSBhbHdheXMgY29tcGFyZWRcbiAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVEcml2ZSA9IHR5cGVvZiBmaWxlWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KGZpbGVbMF0pO1xuICAgICAgICAgICAgY29uc3QgZmlsZVVOQyA9ICFmaWxlRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChmaWxlWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Ecml2ZSA9IHR5cGVvZiBwYXR0ZXJuWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bMF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVyblVOQyA9ICFwYXR0ZXJuRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhdHRlcm5bM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IGZkaSA9IGZpbGVVTkMgPyAzIDogZmlsZURyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBkaSA9IHBhdHRlcm5VTkMgPyAzIDogcGF0dGVybkRyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmRpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcGRpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmZCwgcGRdID0gW2ZpbGVbZmRpXSwgcGF0dGVybltwZGldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmQudG9Mb3dlckNhc2UoKSA9PT0gcGQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BkaV0gPSBmZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBkaSA+IGZkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UocGRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZGkgPiBwZGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKGZkaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbmQgcmVkdWNlIC4gYW5kIC4uIHBvcnRpb25zIGluIHRoZSBmaWxlIGFzIHdlbGwuXG4gICAgICAgIC8vIGRvbnQnIG5lZWQgdG8gZG8gdGhlIHNlY29uZCBwaGFzZSwgYmVjYXVzZSBpdCdzIG9ubHkgb25lIHN0cmluZ1tdXG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5sZXZlbFR3b0ZpbGVPcHRpbWl6ZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIHRoaXMsIHsgZmlsZSwgcGF0dGVybiB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDAsIHBpID0gMCwgZmwgPSBmaWxlLmxlbmd0aCwgcGwgPSBwYXR0ZXJuLmxlbmd0aDsgZmkgPCBmbCAmJiBwaSA8IHBsOyBmaSsrLCBwaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJyk7XG4gICAgICAgICAgICB2YXIgcCA9IHBhdHRlcm5bcGldO1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlW2ZpXTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZik7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKTtcbiAgICAgICAgICAgICAgICAvLyBcIioqXCJcbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgICAgICAgICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi9jXG4gICAgICAgICAgICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgICAgICAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgICAgICAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICAgICAgICAgICAgdmFyIGZyID0gZmk7XG4gICAgICAgICAgICAgICAgdmFyIHByID0gcGkgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmciA9PT0gZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAgICAgICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgICAgICAgICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICAgICAgICAgIGxldCBoaXQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gZiA9PT0gcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gcC50ZXN0KGYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgICAgICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgICAgICAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gICAgICAgIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG4gICAgICAgIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgICAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICAgICAgICAgIHJldHVybiBmaSA9PT0gZmwgLSAxICYmIGZpbGVbZmldID09PSAnJztcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICB9XG4gICAgYnJhY2VFeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiBicmFjZUV4cGFuZCh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBzaG9ydGN1dHNcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqKicpXG4gICAgICAgICAgICByZXR1cm4gR0xPQlNUQVI7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gZmFyIGFuZCBhd2F5LCB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJuIHBhcnRzIGFyZVxuICAgICAgICAvLyAqLCAqLiosIGFuZCAqLjxleHQ+ICBBZGQgYSBmYXN0IGNoZWNrIG1ldGhvZCBmb3IgdGhvc2UuXG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgZmFzdFRlc3QgPSBudWxsO1xuICAgICAgICBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhclRlc3REb3QgOiBzdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdEV4dFJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdCkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHFtYXJrc1JFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0KShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhckRvdFN0YXJUZXN0RG90IDogc3RhckRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChkb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBkb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZSA9IEFTVC5mcm9tR2xvYihwYXR0ZXJuLCB0aGlzLm9wdGlvbnMpLnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIGlmIChmYXN0VGVzdCAmJiB0eXBlb2YgcmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBBdm9pZHMgb3ZlcnJpZGluZyBpbiBmcm96ZW4gZW52aXJvbm1lbnRzXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHJlLCAndGVzdCcsIHsgdmFsdWU6IGZhc3RUZXN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZTtcbiAgICB9XG4gICAgbWFrZVJlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgICAgICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgICAgICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhclxuICAgICAgICAgICAgPyBzdGFyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgPyB0d29TdGFyRG90XG4gICAgICAgICAgICAgICAgOiB0d29TdGFyTm9Eb3Q7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gbmV3IFNldChvcHRpb25zLm5vY2FzZSA/IFsnaSddIDogW10pO1xuICAgICAgICAvLyByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIGlmICoqIGlzIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgICAgIC8vIGlmICoqIGlzIGZpcnN0LCBhbmQgdGhlcmUgYXJlIG1vcmUsIHByZXBlbmQgKFxcL3x0d29TdGFyXFwvKT8gdG8gbmV4dFxuICAgICAgICAvLyBpZiAqKiBpcyBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgICAgICAvLyBpZiAqKiBpcyBpbiB0aGUgbWlkZGxlLCBhcHBlbmQgKFxcL3xcXC90d29TdGFyXFwvKSB0byBwcmV2aW91c1xuICAgICAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgICAgICBsZXQgcmUgPSBzZXRcbiAgICAgICAgICAgIC5tYXAocGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHBhdHRlcm4ubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBwLmZsYWdzLnNwbGl0KCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFkZChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgICAgICAgICAgICAgICA6IHAgPT09IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAuX3NyYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHAuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcFtpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHBwW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAhPT0gR0xPQlNUQVIgfHwgcHJldiA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9ICcoPzpcXFxcL3wnICsgdHdvU3RhciArICdcXFxcLyk/JyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXSA9IHR3b1N0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnKT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXC8pJyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9IEdMT0JTVEFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBwLmZpbHRlcihwID0+IHAgIT09IEdMT0JTVEFSKS5qb2luKCcvJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBuZWVkIHRvIHdyYXAgaW4gcGFyZW5zIGlmIHdlIGhhZCBtb3JlIHRoYW4gb25lIHRoaW5nIHdpdGggfCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgYW5jaG9yZWQgdG8gXiBhbmQgdGhlIGxhc3QgdG8gJFxuICAgICAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gc2V0Lmxlbmd0aCA+IDEgPyBbJyg/OicsICcpJ10gOiBbJycsICcnXTtcbiAgICAgICAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAgICAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICAgICAgcmUgPSAnXicgKyBvcGVuICsgcmUgKyBjbG9zZSArICckJztcbiAgICAgICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0ZSlcbiAgICAgICAgICAgIHJlID0gJ14oPyEnICsgcmUgKyAnKS4rJCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIFsuLi5mbGFnc10uam9pbignJykpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZVxuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgfVxuICAgIHNsYXNoU3BsaXQocCkge1xuICAgICAgICAvLyBpZiBwIHN0YXJ0cyB3aXRoIC8vIG9uIHdpbmRvd3MsIHdlIHByZXNlcnZlIHRoYXRcbiAgICAgICAgLy8gc28gdGhhdCBVTkMgcGF0aHMgYXJlbid0IGJyb2tlbi4gIE90aGVyd2lzZSwgYW55IG51bWJlciBvZlxuICAgICAgICAvLyAvIGNoYXJhY3RlcnMgYXJlIGNvYWxlc2NlZCBpbnRvIG9uZSwgdW5sZXNzXG4gICAgICAgIC8vIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzIGlzIHNldCB0byB0cnVlLlxuICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzV2luZG93cyAmJiAvXlxcL1xcL1teXFwvXSsvLnRlc3QocCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBleHRyYSAnJyBmb3IgdGhlIG9uZSB3ZSBsb3NlXG4gICAgICAgICAgICByZXR1cm4gWycnLCAuLi5wLnNwbGl0KC9cXC8rLyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoL1xcLysvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChmLCBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAgICAgICAvLyBjb21tZW50cywgZXRjLlxuICAgICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmID09PSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGYgPSBmLnNwbGl0KCdcXFxcJykuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgICAgICBjb25zdCBmZiA9IHRoaXMuc2xhc2hTcGxpdChmKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGZmKTtcbiAgICAgICAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAgICAgICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAgICAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgICAgICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KTtcbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZmZbZmYubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmZi5sZW5ndGggLSAyOyAhZmlsZW5hbWUgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZmW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldO1xuICAgICAgICAgICAgbGV0IGZpbGUgPSBmZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gICAgICAgIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdHMoZGVmKSB7XG4gICAgICAgIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2g7XG4gICAgfVxufVxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5leHBvcnQgeyBBU1QgfSBmcm9tICcuL2FzdC5qcyc7XG5leHBvcnQgeyBlc2NhcGUgfSBmcm9tICcuL2VzY2FwZS5qcyc7XG5leHBvcnQgeyB1bmVzY2FwZSB9IGZyb20gJy4vdW5lc2NhcGUuanMnO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbm1pbmltYXRjaC5BU1QgPSBBU1Q7XG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoO1xubWluaW1hdGNoLmVzY2FwZSA9IGVzY2FwZTtcbm1pbmltYXRjaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/unescape.js":
/*!***********************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/esm/unescape.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unescape: () => (/* binding */ unescape)\n/* harmony export */ });\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL3VuZXNjYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1QkFBdUIsZ0NBQWdDLElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21ha2VwaW4yci9Eb2N1bWVudHMvcHJvamVjdHMvbWFrZXBpbjJyLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvZXNtL3VuZXNjYXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW4tZXNjYXBlIGEgc3RyaW5nIHRoYXQgaGFzIGJlZW4gZXNjYXBlZCB3aXRoIHtAbGluayBlc2NhcGV9LlxuICpcbiAqIElmIHRoZSB7QGxpbmsgd2luZG93c1BhdGhzTm9Fc2NhcGV9IG9wdGlvbiBpcyB1c2VkLCB0aGVuIHNxdWFyZS1icmFjZVxuICogZXNjYXBlcyBhcmUgcmVtb3ZlZCwgYnV0IG5vdCBiYWNrc2xhc2ggZXNjYXBlcy4gIEZvciBleGFtcGxlLCBpdCB3aWxsIHR1cm5cbiAqIHRoZSBzdHJpbmcgYCdbKl0nYCBpbnRvIGAqYCwgYnV0IGl0IHdpbGwgbm90IHR1cm4gYCdcXFxcKidgIGludG8gYCcqJ2AsXG4gKiBiZWN1YXNlIGBcXGAgaXMgYSBwYXRoIHNlcGFyYXRvciBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUuXG4gKlxuICogV2hlbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIGlzIG5vdCBzZXQsIHRoZW4gYm90aCBicmFjZSBlc2NhcGVzIGFuZFxuICogYmFja3NsYXNoIGVzY2FwZXMgYXJlIHJlbW92ZWQuXG4gKlxuICogU2xhc2hlcyAoYW5kIGJhY2tzbGFzaGVzIGluIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgbW9kZSkgY2Fubm90IGJlIGVzY2FwZWRcbiAqIG9yIHVuZXNjYXBlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvd3NQYXRoc05vRXNjYXBlXG4gICAgICAgID8gcy5yZXBsYWNlKC9cXFsoW15cXC9cXFxcXSlcXF0vZywgJyQxJylcbiAgICAgICAgOiBzLnJlcGxhY2UoLygoPyFcXFxcKS58XilcXFsoW15cXC9cXFxcXSlcXF0vZywgJyQxJDInKS5yZXBsYWNlKC9cXFxcKFteXFwvXSkvZywgJyQxJyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5lc2NhcGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/esm/unescape.js\n");

/***/ })

};
;